<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Linus’s Blog - Implementing Binary Search</title>
		<link rel="stylesheet" href="../css/base.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Serif+Pro">
		<link rel="shortcut icon" type="image/png" href="../favicon.png">
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="../misc.js"></script>
		<!-- https://github.com/mreid/markreidname-hakyll/blob/master/_templates/mathjax.html -->
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		extensions: ["tex2jax.js"],
		jax: ["input/TeX", "output/HTML-CSS"],
		tex2jax: {
			inlineMath: [ ["\\(","\\)"] ],
			displayMath: [ ["\\[","\\]"] ],
			processEscapes: true
		},
		TeX: { equationNumbers: { autoNumber: "AMS" } },
		"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>

	</head>
	<body>
		<div id="header">
			<a href="../">funloop.org</a>
			|
			<a href="../about.html">About</a>
		</div>

		<div id="sticky-title">
			<h1 class="center" id="page-title">Implementing Binary Search</h1>
		</div>

		<div id="content">
			<div class="info center">
	<a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2014-12-13-implementing-binary-search.org" title="History"><code class="date">2014-12-13</code></a>
	<br>
	<a title="All pages tagged 'programming'." href="../tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged 'c'." href="../tag/c.html" rel="tag">c</a>, <a title="All pages tagged 'ruby'." href="../tag/ruby.html" rel="tag">ruby</a>, <a title="All pages tagged 'haskell'." href="../tag/haskell.html" rel="tag">haskell</a>
</div>

<p>If you are a programmer, I’m sure you’ve encountered the term <em>binary
search</em> at some point in time. I know what binary search is, but I’m
writing this post to solidify my understanding of it. I also want to
compare how it might be naively implemented across my 3 favorite
languages C, Ruby, and Haskell — because naive code is the best code
(to learn from)!</p>
<h1 id="binary-subdivision">Binary Subdivision</h1>
<p>You can skip this section if you want — I merely want to write how I
first met and fell in love with the concept of <em>binary subdivision</em>. I
first discovered binary division when I was in high school. It was a
very pleasant realization, and at the time I did not fully realize what
I had accidentally encountered.</p>
<p>The situation was so: my Biology teacher, Mr. Kennedy, told everyone to
draw an even 4x4 square grid on the palms of our hands. Everyone was
supposed to draw their own 4x4 grid — but this was when I asked
myself, “how can I draw the most even-looking grid without using a
ruler?” You see, I could not use a ruler because I was using my right
hand to draw onto my left hand — and to hold a ruler properly I would
need a third hand! So there was the problem.</p>
<p>On the one hand, I could not simply draw the four horizontal and four
vertical lines one after the other, left to right, top to bottom,
because I knew that I would introduce a great deal of additive
error.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> I did not want to draw an ugly, lopsided square.</p>
<p>It took me a few seconds, but I came up with a plan. I first drew a
single large square. Then knowing that I could easily eyeball with good
accuracy where the <em>middle point of that square</em> was horizontally, I
drew a vertical line down the <em>middle</em>. I then did the same thing in the
other axis vertically. I repeated this procedure a few more times,
<em>recursively subdividing</em> each smaller rectangular shape into halves,
finally ending up with a nice-looking grid. I glanced around the room,
and later looked at other students’ palms to see if they had discovered
this “divide by <span class="math inline">\(\frac{1}{2}\)</span>” trick, but to my dismay no one had done
it; I knew this was the case because everybody else’s square was sloppy.</p>
<p>I cannot honestly say if this was the very first time I realized the
underlying geometric concepts at play here, but I can affirmatively say
that it really was the first time I systematically applied such an
elegant solution to a given problem. I wonder if most people who draw
grids even bother to think of it as a problem.</p>
<p>To me, binary subdivision is the underpinning principle behind binary
search. Continued subdvision by halves is like exponentiation in
reverse; pretty soon, you end up with extremely tiny numbers. This is
where the power of binary search comes from! Simply put, binary search
is like binary subdivision, but you get to subdivide <em>toward</em> the
location of whatever you’re looking for. Isn’t that cool?</p>
<h1 id="the-problem">The Problem</h1>
<p>The problem is simple — given a <strong>sorted</strong> list <code class="verbatim">KEYS</code> of items (for
simplicity’s sake, positive integers), determine if <code class="verbatim">key</code> is in it, and
also, the position of <code class="verbatim">key</code> in the list if it is indeed in the list. The
catch is that you have no idea as to the contents of <code class="verbatim">KEYS</code> — only
that it is sorted from smallest to largest.</p>
<h1 id="naive-approach-linear-search">Naive Approach — Linear Search</h1>
<p>The simplest way of doing this is by linear search. It is probably the
novice programmer’s first reaction. You just start from the first item
in <code class="verbatim">KEYS</code>, and run a <strong>for</strong>-loop all the way across the list, looking at
every single item. There are now two possibilities — either (1) you
indeed discover <code class="verbatim">key</code>, and report back your position (aka the “index”,
usually in the form of the familiar <code class="verbatim">i</code> variable in C/C++/Java code), or
(2) you find nothing. If you are clever, you can optimize the search in
the second situation by breaking out of the <strong>for</strong>-loop if the items you
are comparing are larger than <code class="verbatim">key</code>; after all, <code class="verbatim">KEYS</code> is sorted, so we
know for a fact that the later numbers are only going to get bigger, so
there is no point in trying to find <code class="verbatim">key</code> in that crowd of numbers.</p>
<p>But think of the consequences — what’s the worst case scenario?
Imagine you have 1 trillion items, and that <code class="verbatim">key</code> is not in it, because
let’s say <code class="verbatim">key</code> is a much bigger number than the biggest number in
<code class="verbatim">KEYS</code> — but of course you haven’t run the linear search yet, so you
don’t know that. Given this situation, you would have to search the
<em>entire</em> list of all numbers in <code class="verbatim">KEYS</code> before reaching condition (2)
described above.</p>
<p>If you wanted to get a little more clever to avoid this problem of
searching all 1 trillion items, you could tell the algorithm to refuse
to enter the <strong>for</strong>-loop if <code class="verbatim">key</code> lies outside the <em>bounds</em> of <code class="verbatim">KEYS</code>.
Checking the bounds is easy and takes constant time, as you merely check
for the first and last item’s size (again, as <code class="verbatim">KEYS</code> is sorted), and
those are your bounds. This way, if <code class="verbatim">key</code> lies outside the bounds, you
can <em>guarantee</em> that it is not in <code class="verbatim">KEYS</code>, no matter how many items
<code class="verbatim">KEYS</code> has.</p>
<p>And, this is it. There is nothing more to optimize using this method
(let’s not get into parallelization). What else can you do, really, when
searching linearly, looping through every item from the beginning to the
next?</p>
<h1 id="inverted-bounds-checking-aka-binary-search">Inverted Bounds-Checking, aka Binary Search</h1>
<p>The heading of this subsection might have already given you a hint as to
what binary search entails. (Although, if you’ve read the <em>Binary
Subdivision</em> section, you should have had a good idea anyhow.) Binary
search takes the concept of bounds-checking, and applies it repeatedly,
recursively, against <code class="verbatim">KEYS</code>. The only difference when I say
“bounds-checking” in the context of binary search is that we do <em>not</em>
care about the values of those bounds, but merely that they <em>are</em> the
bounds. This is because we only concern ourselves with dividing the list
of sorted numbers by <span class="math inline">\(\frac{1}{2}\)</span> every time and take the <em>middle</em>
index <code class="verbatim">middle_index</code>, which is located as close as possible to the
middle element (halfway between the two bounds). Indeed, the only way to
get a valid <code class="verbatim">middle_index</code> value is if we know the bounds (the size of
the list). We keep doing this recursively until <code class="verbatim">KEYS[mid] =</code> key=.</p>
<p>The following is the pseudocode.</p>
<div class="code-and-raw">
<div class="sourceCode" id="cb1" data-startFrom="1"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb1-1"><a href="#cb1-1"></a>KEYS = some random list of numbers</span>
<span id="cb1-2"><a href="#cb1-2"></a>key = the number we're looking for in KEYS</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>binary_search(KEYS, key):</span>
<span id="cb1-5"><a href="#cb1-5"></a>	middle_index = get_middle_index_index(length of KEYS)</span>
<span id="cb1-6"><a href="#cb1-6"></a>	lower_KEYS = get_below(middle_index, KEYS)</span>
<span id="cb1-7"><a href="#cb1-7"></a>	upper_KEYS = get_above(middle_index, KEYS)</span>
<span id="cb1-8"><a href="#cb1-8"></a>	if key &lt; KEYS[middle_index]</span>
<span id="cb1-9"><a href="#cb1-9"></a>		binary_search(lower_KEYS, key)</span>
<span id="cb1-10"><a href="#cb1-10"></a>	else if key &gt; KEYS[middle_index]</span>
<span id="cb1-11"><a href="#cb1-11"></a>		binary_search(upper_KEYS, key)</span>
<span id="cb1-12"><a href="#cb1-12"></a>	else</span>
<span id="cb1-13"><a href="#cb1-13"></a>		return middle_index</span>
<span id="cb1-14"><a href="#cb1-14"></a>	end</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>binary-search-pseudo-0.txt</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/binary-search-pseudo-0.txt"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/binary-search-pseudo-0.txt" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>There are some obvious holes in the code above.</p>
<p>First, we always assume that <code class="verbatim">KEYS</code> is made up of multiple elements, and
that its halves <code class="verbatim">lower_keys</code> and <code class="verbatim">upper_keys</code> also have multiple
elements in them. In the extreme case, <code class="verbatim">KEYS</code> might be an empty list,
which would make the whole thing explode.</p>
<p>Second, the <code class="verbatim">get_middle_index()</code>, <code class="verbatim">get_below_mid()</code>, and
<code class="verbatim">get_above_mid()</code> functions remain undefined.</p>
<p>Aside: You might be wondering about lines 12-14. We could write</p>
<pre class="example"><code>else if key == KEYS[mid]
</code></pre>
<p>instead of just <code class="verbatim">else</code> on line 12, but that is redundant. This is
because we already test for the two other conditions of <code class="verbatim">key</code> being
<em>lesser</em> or <em>greater</em> than <code class="verbatim">middle_index</code>. Therefore, we’ve excluded the
two other conditions and are already only left with the third condition
of <code class="verbatim">key =</code> KEYS[mid]= evaluating to TRUE — hence we write just <code class="verbatim">else</code>
on line 12.</p>
<p>Addressing the holes above, we get the next version.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="code-and-raw">
<div class="sourceCode" id="cb3" data-startFrom="1"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb3-1"><a href="#cb3-1"></a>KEYS = some random list of numbers</span>
<span id="cb3-2"><a href="#cb3-2"></a>first_index = 0</span>
<span id="cb3-3"><a href="#cb3-3"></a>last_index = 999 (our KEYS is 1000 elements big)</span>
<span id="cb3-4"><a href="#cb3-4"></a>key = the number we're looking for in KEYS</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a>binary_search(KEYS, key, first_index, last_index):</span>
<span id="cb3-7"><a href="#cb3-7"></a>	list_size = (last_index - first_index) + 1</span>
<span id="cb3-8"><a href="#cb3-8"></a>	if list_size == 0</span>
<span id="cb3-9"><a href="#cb3-9"></a>		return KEY_NOT_FOUND</span>
<span id="cb3-10"><a href="#cb3-10"></a>	end</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>	middle_index = list_size / 2 + first_index</span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a>	if key &lt; KEYS[middle_index]</span>
<span id="cb3-15"><a href="#cb3-15"></a>		binary_search(KEYS, key, first_index, middle_index - 1)</span>
<span id="cb3-16"><a href="#cb3-16"></a>	else if key &gt; KEYS[middle_index]</span>
<span id="cb3-17"><a href="#cb3-17"></a>		binary_search(KEYS, key, middle_index + 1, last_index)</span>
<span id="cb3-18"><a href="#cb3-18"></a>	else</span>
<span id="cb3-19"><a href="#cb3-19"></a>		return middle_index</span>
<span id="cb3-20"><a href="#cb3-20"></a>	end</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>binary-search-pseudo-1.txt</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/binary-search-pseudo-1.txt"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/binary-search-pseudo-1.txt" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>There are some obvious differences — mainly the fact that we concern
ourselves primarily with the first and last index numbers of the list,
and work with these indices instead of working with the entire list
<code class="verbatim">KEYS</code> itself. The <code class="verbatim">get_below()</code> and <code class="verbatim">get_above()</code> functions are gone
and have been replaced with the index bounds <code class="verbatim">first_index, middle_index</code>
and <code class="verbatim">middle_index + 1, last_index</code>, respectively. As you can see,
working with these index numbers directly avoids a lot of abstraction.
Actually, the <code class="verbatim">list_size</code> abstraction can be further reduced in terms of
indices, so that <code class="verbatim">list_size =</code> 0= can be rewritten as
<code class="verbatim">first_index &gt; last_index</code>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<h1 id="theoretical-performance">Theoretical Performance</h1>
<p>You can probably see why binary search is so powerful. It repeatedly
divides the search region into <span class="math inline">\(\frac{1}{2}\)</span> of its original size. It’s
sort of like <a href="http://en.wikipedia.org/wiki/Zeno%27s_paradoxes">Zeno’s Dichotomy Paradox</a>, except that it uses the “absurdity” of Zeno’s
argument, and uses that to its advantage. To me, these somewhat related,
even tangential, connections make binary search that much more elegant.</p>
<p>Consider this: a list that has 100,000 elements will only take, in the
worst case, around 16 calls. Compare that to linear search, which will
take at most 100,000 calls or iterations (if our item happens to be at
the very last index).<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> The time complexity of binary search for a
list of <span class="math inline">\(\mathit{KEYS\_TOTAL}\)</span> elements is defined to be
<span class="math inline">\(\lfloor\log_2\mathit{KEYS\_TOTAL}\rfloor\)</span>. Because this defines an
exponential relationship, we can rest assured that we can <em>cut down</em> a
very large list quickly.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<h1 id="naive-implementations">Naive Implementations</h1>
<h2 id="preliminary-details">Preliminary Details</h2>
<p>I said at the beginning of the post that I would show a naive
implementation in C, Ruby, and Haskell. I could have simply written a
<code class="verbatim">binary_search()</code> function (and only that function) for all three
languages — but instead I chose to write full standalone programs for
all three that print out the same results. Because they are all
standalone programs, you can easily tweak some settings (namely, the
<code class="verbatim">KEYS_TOTAL</code> value), and see how it scales.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> All versions use the
new <a href="http://www.pcg-random.org">PCG family</a> of pseudorandom number
generators (RNGs), which have been created by Prof. Melissa E. O’Neill,
author of the great paper <em>The Genuine Sieve of Eratosthenes</em>.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<h2 id="c-version-linux">C Version (Linux)</h2>
<div class="code-and-raw">
<div class="sourceCode" id="cb4" data-startFrom="1"><pre class="sourceCode numberSource numberLines c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">/*</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co"> * LICENSE: PUBLIC DOMAIN</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co"> *</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co"> * Compile with `gcc -o binary-search-c -Wall -Wextra -Wpedantic --std=gnu11 -O2</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co"> * binary-search.c'. Check via valgrind with `valgrind --leak-check=full</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co"> * --show-leak-kinds=all -v path/to/binary'.</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co"> *</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co"> * Usage: just execute the binary as-is without any arguments. To test the RNG,</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co"> * call with the argument &quot;rng&quot;.</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co"> */</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span><span class="pp"> </span><span class="co">/* bool */</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span><span class="pp"> </span><span class="co">/* UINT32_MAX */</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span><span class="pp"> </span><span class="co">/* malloc() */</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span><span class="pp"> </span><span class="co">/* strcmp() */</span></span>
<span id="cb4-17"><a href="#cb4-17"></a><span class="pp">#include </span><span class="im">&lt;inttypes.h&gt;</span><span class="pp"> </span><span class="co">/* uint32_t */</span></span>
<span id="cb4-18"><a href="#cb4-18"></a></span>
<span id="cb4-19"><a href="#cb4-19"></a><span class="kw">typedef</span> <span class="dt">uint32_t</span> u32<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="kw">typedef</span> <span class="dt">uint64_t</span> u64<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21"></a></span>
<span id="cb4-22"><a href="#cb4-22"></a><span class="co">/*</span></span>
<span id="cb4-23"><a href="#cb4-23"></a><span class="co"> * &quot;-1&quot; is an invalid value to be used as an index for an array (the index</span></span>
<span id="cb4-24"><a href="#cb4-24"></a><span class="co"> * number is what binary_search() looks for.)</span></span>
<span id="cb4-25"><a href="#cb4-25"></a><span class="co"> */</span></span>
<span id="cb4-26"><a href="#cb4-26"></a><span class="kw">enum</span> <span class="op">{</span>KEY_NOT_FOUND <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb4-27"><a href="#cb4-27"></a><span class="dt">const</span> <span class="dt">int</span> KEYS_TOTAL <span class="op">=</span> <span class="dv">1000000</span><span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28"></a></span>
<span id="cb4-29"><a href="#cb4-29"></a><span class="co">// *Really* minimal PCG32 code / (c) 2014 M.E. O'Neill / pcg-random.org</span></span>
<span id="cb4-30"><a href="#cb4-30"></a><span class="co">// Licensed under Apache License 2.0 (NO WARRANTY, etc. see website)</span></span>
<span id="cb4-31"><a href="#cb4-31"></a></span>
<span id="cb4-32"><a href="#cb4-32"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span> u64 state<span class="op">;</span>  <span class="dt">uint64_t</span> inc<span class="op">;</span> <span class="op">}</span> pcg32_random_t<span class="op">;</span></span>
<span id="cb4-33"><a href="#cb4-33"></a></span>
<span id="cb4-34"><a href="#cb4-34"></a>u32 pcg32_random_r<span class="op">(</span>pcg32_random_t <span class="op">*</span>rng<span class="op">)</span></span>
<span id="cb4-35"><a href="#cb4-35"></a><span class="op">{</span></span>
<span id="cb4-36"><a href="#cb4-36"></a>	u64 oldstate <span class="op">=</span> rng<span class="op">-&gt;</span>state<span class="op">;</span></span>
<span id="cb4-37"><a href="#cb4-37"></a>	rng<span class="op">-&gt;</span>state <span class="op">=</span> oldstate <span class="op">*</span> <span class="dv">6364136223846793005</span><span class="bu">ULL</span> <span class="op">+</span> <span class="op">(</span>rng<span class="op">-&gt;</span>inc<span class="op">|</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-38"><a href="#cb4-38"></a>	u32 xorshifted <span class="op">=</span> <span class="op">((</span>oldstate <span class="op">&gt;&gt;</span> <span class="dv">18</span><span class="bu">u</span><span class="op">)</span> <span class="op">^</span> oldstate<span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="dv">27</span><span class="bu">u</span><span class="op">;</span></span>
<span id="cb4-39"><a href="#cb4-39"></a>	u32 rot <span class="op">=</span> oldstate <span class="op">&gt;&gt;</span> <span class="dv">59</span><span class="bu">u</span><span class="op">;</span></span>
<span id="cb4-40"><a href="#cb4-40"></a>	<span class="cf">return</span> <span class="op">(</span>xorshifted <span class="op">&gt;&gt;</span> rot<span class="op">)</span> <span class="op">|</span> <span class="op">(</span>xorshifted <span class="op">&lt;&lt;</span> <span class="op">((-</span>rot<span class="op">)</span> <span class="op">&amp;</span> <span class="dv">31</span><span class="op">));</span></span>
<span id="cb4-41"><a href="#cb4-41"></a><span class="op">}</span></span>
<span id="cb4-42"><a href="#cb4-42"></a></span>
<span id="cb4-43"><a href="#cb4-43"></a>u32 uniform32<span class="op">(</span><span class="dt">int</span> range<span class="op">,</span> pcg32_random_t <span class="op">*</span>rng<span class="op">)</span></span>
<span id="cb4-44"><a href="#cb4-44"></a><span class="op">{</span></span>
<span id="cb4-45"><a href="#cb4-45"></a>	<span class="dt">unsigned</span> rand_limit<span class="op">,</span> rand_excess<span class="op">;</span></span>
<span id="cb4-46"><a href="#cb4-46"></a>	u32 x<span class="op">;</span></span>
<span id="cb4-47"><a href="#cb4-47"></a>	rand_excess <span class="op">=</span> <span class="op">((</span>UINT32_MAX <span class="op">%</span> range<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> range<span class="op">;</span></span>
<span id="cb4-48"><a href="#cb4-48"></a>	rand_limit <span class="op">=</span> UINT32_MAX <span class="op">-</span> rand_excess<span class="op">;</span></span>
<span id="cb4-49"><a href="#cb4-49"></a>	<span class="cf">while</span> <span class="op">((</span>x <span class="op">=</span> pcg32_random_r<span class="op">(</span>rng<span class="op">))</span> <span class="op">&gt;</span> rand_limit<span class="op">)</span> <span class="op">{};</span></span>
<span id="cb4-50"><a href="#cb4-50"></a>	<span class="cf">return</span> x <span class="op">%</span> range<span class="op">;</span></span>
<span id="cb4-51"><a href="#cb4-51"></a><span class="op">}</span></span>
<span id="cb4-52"><a href="#cb4-52"></a></span>
<span id="cb4-53"><a href="#cb4-53"></a><span class="co">/* Populate an array with increasing numbers; we randomly choose whether to skip</span></span>
<span id="cb4-54"><a href="#cb4-54"></a><span class="co"> * to the next number by an increment of 1 or 2, so as to initialize the array</span></span>
<span id="cb4-55"><a href="#cb4-55"></a><span class="co"> * slightly differently each time this function is called.</span></span>
<span id="cb4-56"><a href="#cb4-56"></a><span class="co"> */</span></span>
<span id="cb4-57"><a href="#cb4-57"></a>u32 init_array<span class="op">(</span>u32 <span class="op">*</span>keys<span class="op">,</span> <span class="dt">bool</span> has_key<span class="op">,</span> pcg32_random_t <span class="op">*</span>rng<span class="op">)</span></span>
<span id="cb4-58"><a href="#cb4-58"></a><span class="op">{</span></span>
<span id="cb4-59"><a href="#cb4-59"></a>	<span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb4-60"><a href="#cb4-60"></a>	<span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> KEYS_TOTAL<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-61"><a href="#cb4-61"></a>		j <span class="op">+=</span> uniform32<span class="op">(</span><span class="dv">2</span><span class="op">,</span> rng<span class="op">);</span></span>
<span id="cb4-62"><a href="#cb4-62"></a>		keys<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i <span class="op">+</span> j<span class="op">;</span></span>
<span id="cb4-63"><a href="#cb4-63"></a>	<span class="op">}</span></span>
<span id="cb4-64"><a href="#cb4-64"></a></span>
<span id="cb4-65"><a href="#cb4-65"></a>	<span class="co">/*</span></span>
<span id="cb4-66"><a href="#cb4-66"></a><span class="co">	 * If we want to choose a key, randomly choose one from one of the</span></span>
<span id="cb4-67"><a href="#cb4-67"></a><span class="co">	 * existing elements; otherwise, return an impossible key (where</span></span>
<span id="cb4-68"><a href="#cb4-68"></a><span class="co">	 * &quot;impossible&quot; means a key whose value lies outside the range of values</span></span>
<span id="cb4-69"><a href="#cb4-69"></a><span class="co">	 * that exist in the array).</span></span>
<span id="cb4-70"><a href="#cb4-70"></a><span class="co">	 */</span></span>
<span id="cb4-71"><a href="#cb4-71"></a>	<span class="cf">if</span> <span class="op">(</span>has_key<span class="op">)</span></span>
<span id="cb4-72"><a href="#cb4-72"></a>		<span class="cf">return</span> keys<span class="op">[</span>uniform32<span class="op">(</span>KEYS_TOTAL<span class="op">,</span> rng<span class="op">)];</span></span>
<span id="cb4-73"><a href="#cb4-73"></a>	<span class="cf">else</span></span>
<span id="cb4-74"><a href="#cb4-74"></a>		<span class="co">/* Impossible key = biggest key + 1 */</span></span>
<span id="cb4-75"><a href="#cb4-75"></a>		<span class="cf">return</span> keys<span class="op">[</span>KEYS_TOTAL <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-76"><a href="#cb4-76"></a><span class="op">}</span></span>
<span id="cb4-77"><a href="#cb4-77"></a></span>
<span id="cb4-78"><a href="#cb4-78"></a><span class="dt">int</span> binary_search<span class="op">(</span>u32 <span class="op">*</span>keys<span class="op">,</span> u32 key<span class="op">,</span> <span class="dt">int</span> min<span class="op">,</span> <span class="dt">int</span> max<span class="op">)</span></span>
<span id="cb4-79"><a href="#cb4-79"></a><span class="op">{</span></span>
<span id="cb4-80"><a href="#cb4-80"></a>	<span class="dt">int</span> list_size<span class="op">;</span></span>
<span id="cb4-81"><a href="#cb4-81"></a>	<span class="dt">int</span> mid<span class="op">;</span></span>
<span id="cb4-82"><a href="#cb4-82"></a></span>
<span id="cb4-83"><a href="#cb4-83"></a>	list_size <span class="op">=</span> <span class="op">(</span>max <span class="op">-</span> min<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-84"><a href="#cb4-84"></a>	<span class="cf">if</span> <span class="op">(</span>list_size <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb4-85"><a href="#cb4-85"></a>		<span class="cf">return</span> KEY_NOT_FOUND<span class="op">;</span></span>
<span id="cb4-86"><a href="#cb4-86"></a></span>
<span id="cb4-87"><a href="#cb4-87"></a>	mid <span class="op">=</span> <span class="op">(</span>list_size <span class="op">/</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span> min<span class="op">;</span></span>
<span id="cb4-88"><a href="#cb4-88"></a></span>
<span id="cb4-89"><a href="#cb4-89"></a>	<span class="cf">if</span> <span class="op">(</span>key <span class="op">&lt;</span> keys<span class="op">[</span>mid<span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-90"><a href="#cb4-90"></a>		<span class="cf">return</span> binary_search<span class="op">(</span>keys<span class="op">,</span> key<span class="op">,</span> min<span class="op">,</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-91"><a href="#cb4-91"></a>	<span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>key <span class="op">&gt;</span> keys<span class="op">[</span>mid<span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-92"><a href="#cb4-92"></a>		<span class="cf">return</span> binary_search<span class="op">(</span>keys<span class="op">,</span> key<span class="op">,</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> max<span class="op">);</span></span>
<span id="cb4-93"><a href="#cb4-93"></a>	<span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-94"><a href="#cb4-94"></a>		<span class="cf">return</span> mid<span class="op">;</span></span>
<span id="cb4-95"><a href="#cb4-95"></a>	<span class="op">}</span></span>
<span id="cb4-96"><a href="#cb4-96"></a><span class="op">}</span></span>
<span id="cb4-97"><a href="#cb4-97"></a></span>
<span id="cb4-98"><a href="#cb4-98"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">**</span>argv<span class="op">)</span></span>
<span id="cb4-99"><a href="#cb4-99"></a><span class="op">{</span></span>
<span id="cb4-100"><a href="#cb4-100"></a>	<span class="dt">int</span> i<span class="op">,</span> min<span class="op">,</span> max<span class="op">;</span></span>
<span id="cb4-101"><a href="#cb4-101"></a>	<span class="dt">int</span> mid<span class="op">;</span></span>
<span id="cb4-102"><a href="#cb4-102"></a>	<span class="dt">bool</span> has_key<span class="op">;</span></span>
<span id="cb4-103"><a href="#cb4-103"></a>	u32 <span class="op">*</span>keys<span class="op">;</span></span>
<span id="cb4-104"><a href="#cb4-104"></a>	u32 key<span class="op">;</span></span>
<span id="cb4-105"><a href="#cb4-105"></a>	pcg32_random_t rng <span class="op">=</span> <span class="op">{</span><span class="bn">0x1234567890abcdef</span><span class="bu">ULL</span><span class="op">,</span> <span class="bn">0x1234567890abcdef</span><span class="bu">ULL</span><span class="op">};</span></span>
<span id="cb4-106"><a href="#cb4-106"></a></span>
<span id="cb4-107"><a href="#cb4-107"></a>	<span class="co">/* RNG self-test. */</span></span>
<span id="cb4-108"><a href="#cb4-108"></a>	<span class="cf">if</span> <span class="op">(</span>argc <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> strcmp<span class="op">(</span>argv<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="st">&quot;rng&quot;</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-109"><a href="#cb4-109"></a>		printf<span class="op">(</span><span class="st">&quot;Running RNG self-test.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-110"><a href="#cb4-110"></a>		printf<span class="op">(</span><span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> pcg32_random_r<span class="op">(&amp;</span>rng<span class="op">));</span></span>
<span id="cb4-111"><a href="#cb4-111"></a>		<span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">1000000</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-112"><a href="#cb4-112"></a>			pcg32_random_r<span class="op">(&amp;</span>rng<span class="op">);</span></span>
<span id="cb4-113"><a href="#cb4-113"></a>		<span class="op">}</span></span>
<span id="cb4-114"><a href="#cb4-114"></a>		printf<span class="op">(</span><span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> pcg32_random_r<span class="op">(&amp;</span>rng<span class="op">));</span></span>
<span id="cb4-115"><a href="#cb4-115"></a>		<span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">100</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-116"><a href="#cb4-116"></a>			printf<span class="op">(</span><span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb4-117"><a href="#cb4-117"></a>				uniform32<span class="op">((</span>UINT32_MAX <span class="op">/</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span>UINT32_MAX <span class="op">/</span> <span class="dv">3</span><span class="op">),</span></span>
<span id="cb4-118"><a href="#cb4-118"></a>				<span class="op">&amp;</span>rng<span class="op">));</span></span>
<span id="cb4-119"><a href="#cb4-119"></a>		<span class="op">}</span></span>
<span id="cb4-120"><a href="#cb4-120"></a>		keys <span class="op">=</span> malloc<span class="op">(</span>KEYS_TOTAL <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>u32<span class="op">));</span></span>
<span id="cb4-121"><a href="#cb4-121"></a>		<span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-122"><a href="#cb4-122"></a>			has_key <span class="op">=</span> <span class="op">(</span><span class="dt">bool</span><span class="op">)</span>uniform32<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="op">&amp;</span>rng<span class="op">);</span></span>
<span id="cb4-123"><a href="#cb4-123"></a>			key <span class="op">=</span> init_array<span class="op">(</span>keys<span class="op">,</span> has_key<span class="op">,</span> <span class="op">&amp;</span>rng<span class="op">);</span></span>
<span id="cb4-124"><a href="#cb4-124"></a>			printf<span class="op">(</span><span class="st">&quot;last number in array </span><span class="sc">%d</span><span class="st"> for key %&quot;</span>PRIu32<span class="st">&quot;: &quot;</span><span class="op">,</span></span>
<span id="cb4-125"><a href="#cb4-125"></a>				i<span class="op">,</span> key<span class="op">);</span></span>
<span id="cb4-126"><a href="#cb4-126"></a>			printf<span class="op">(</span><span class="st">&quot;%&quot;</span>PRIu32<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> keys<span class="op">[</span>KEYS_TOTAL <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb4-127"><a href="#cb4-127"></a>		<span class="op">}</span></span>
<span id="cb4-128"><a href="#cb4-128"></a>		printf<span class="op">(</span><span class="st">&quot;Done.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-129"><a href="#cb4-129"></a>		printf<span class="op">(</span><span class="st">&quot;END C VERSION</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-130"><a href="#cb4-130"></a>		free<span class="op">(</span>keys<span class="op">);</span></span>
<span id="cb4-131"><a href="#cb4-131"></a>		<span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-132"><a href="#cb4-132"></a>	<span class="op">}</span></span>
<span id="cb4-133"><a href="#cb4-133"></a></span>
<span id="cb4-134"><a href="#cb4-134"></a>	<span class="co">/*</span></span>
<span id="cb4-135"><a href="#cb4-135"></a><span class="co">	 * Allocate space for our big array of keys, as well as our</span></span>
<span id="cb4-136"><a href="#cb4-136"></a><span class="co">	 * in-place-modified &quot;mid&quot; value.</span></span>
<span id="cb4-137"><a href="#cb4-137"></a><span class="co">	 */</span></span>
<span id="cb4-138"><a href="#cb4-138"></a>	keys <span class="op">=</span> malloc<span class="op">(</span>KEYS_TOTAL <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>u32<span class="op">));</span></span>
<span id="cb4-139"><a href="#cb4-139"></a></span>
<span id="cb4-140"><a href="#cb4-140"></a>	<span class="co">/* Stress-test binary_search(). */</span></span>
<span id="cb4-141"><a href="#cb4-141"></a>	<span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-142"><a href="#cb4-142"></a>		has_key <span class="op">=</span> <span class="op">(</span><span class="dt">bool</span><span class="op">)</span>uniform32<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="op">&amp;</span>rng<span class="op">);</span></span>
<span id="cb4-143"><a href="#cb4-143"></a>		key <span class="op">=</span> init_array<span class="op">(</span>keys<span class="op">,</span> has_key<span class="op">,</span> <span class="op">&amp;</span>rng<span class="op">);</span></span>
<span id="cb4-144"><a href="#cb4-144"></a>		min <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-145"><a href="#cb4-145"></a>		max <span class="op">=</span> KEYS_TOTAL <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-146"><a href="#cb4-146"></a>		mid <span class="op">=</span> binary_search<span class="op">(</span>keys<span class="op">,</span> key<span class="op">,</span> min<span class="op">,</span> max<span class="op">);</span></span>
<span id="cb4-147"><a href="#cb4-147"></a>		printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%02d</span><span class="st"> - &quot;</span><span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-148"><a href="#cb4-148"></a>		<span class="cf">if</span> <span class="op">(</span>mid <span class="op">==</span> KEY_NOT_FOUND<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-149"><a href="#cb4-149"></a>			printf<span class="op">(</span><span class="st">&quot;key `%&quot;</span>PRIu32<span class="st">&quot;' not found.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> key<span class="op">);</span></span>
<span id="cb4-150"><a href="#cb4-150"></a>		<span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-151"><a href="#cb4-151"></a>			printf<span class="op">(</span><span class="st">&quot;key `%&quot;</span>PRIu32<span class="st">&quot;' found at keys[</span><span class="sc">%d</span><span class="st">].</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb4-152"><a href="#cb4-152"></a>				key<span class="op">,</span> mid<span class="op">);</span></span>
<span id="cb4-153"><a href="#cb4-153"></a>		<span class="op">}</span></span>
<span id="cb4-154"><a href="#cb4-154"></a>	<span class="op">}</span></span>
<span id="cb4-155"><a href="#cb4-155"></a></span>
<span id="cb4-156"><a href="#cb4-156"></a>	printf<span class="op">(</span><span class="st">&quot;END C VERSION</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-157"><a href="#cb4-157"></a>	free<span class="op">(</span>keys<span class="op">);</span></span>
<span id="cb4-158"><a href="#cb4-158"></a>	<span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-159"><a href="#cb4-159"></a><span class="op">}</span></span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>binary-search.c</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/binary-search.c"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/binary-search.c" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>Overview:</p>
<ul>
<li><code class="verbatim">pcg32_random_r()</code> is PCG’s minimal implementation version. This is
RNG we depend on to get identical randomly-generated data in the other
Ruby and Haskell versions.</li>
<li><code class="verbatim">uniform32()</code> tames all raw RNG’s like <code class="verbatim">pcg32_random_r()</code>; it
<a href="2013-07-12-generating-random-numbers-without-modulo-bias.html">removes any bias</a> that might be introduced if we were to use a simple modulo
operation. Hence, we use <code class="verbatim">uniform32()</code> for all our RNG needs.</li>
<li><code class="verbatim">init_array()</code> takes an empty array of fixed size, and populates it
with semi-random numbers. I say <em>semi-random</em> because the number
chosen to populate the array, in sequence, is steadily bumped up with
the <code class="verbatim">j</code> variable, <strong>eliminating the need for sorting it afterwards</strong> in
preparation for passing it to <code class="verbatim">binary_search()</code>.</li>
<li>Finally, we have <code class="verbatim">binary_search()</code> itself, written in a way to closely
match the pseudocode presented above.</li>
</ul>
<p>I’ve tried to keep the code simple. You may find it disturbing that we
use the same type for <code class="verbatim">KEY_NOT_FOUND</code> as the actual valid key value
(<code class="verbatim">mid</code>) itself. This kind of type overloading is common in C, and is
what gives C its bare metal speed — at the cost of (probable)
disaster, of course.</p>
<h2 id="ruby-version">Ruby Version</h2>
<div class="code-and-raw">
<div class="sourceCode" id="cb5" data-startFrom="1"><pre class="sourceCode numberSource numberLines ruby"><code class="sourceCode ruby"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># LICENSE: PUBLIC DOMAIN</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co"># Interact with `irb -I . -r path/to/this/file'.</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co"># Usage: just execute the binary as-is without any arguments. To test the RNG,</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co"># call with the argument &quot;rng&quot;.</span></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="cn">U32_MAX</span> <span class="kw">=</span> <span class="bn">0xffffffff</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="cn">U64_MAX</span> <span class="kw">=</span> <span class="bn">0xffffffffffffffff</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="cn">U32_MOD</span> <span class="kw">=</span> <span class="cn">U32_MAX</span> <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="cn">U64_MOD</span> <span class="kw">=</span> <span class="cn">U64_MAX</span> <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="cn">KEYS_TOTAL</span> <span class="kw">=</span> <span class="dv">1000000</span></span>
<span id="cb5-14"><a href="#cb5-14"></a></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="cf">class</span> <span class="cn">PCG32</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>	<span class="ot">@state</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>	<span class="ot">@inc</span></span>
<span id="cb5-18"><a href="#cb5-18"></a></span>
<span id="cb5-19"><a href="#cb5-19"></a>	<span class="cf">def</span> initialize(state, inc)</span>
<span id="cb5-20"><a href="#cb5-20"></a>		<span class="ot">@state</span> <span class="kw">=</span> state</span>
<span id="cb5-21"><a href="#cb5-21"></a>		<span class="ot">@inc</span> <span class="kw">=</span> inc</span>
<span id="cb5-22"><a href="#cb5-22"></a>	<span class="cf">end</span></span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a>	<span class="cf">def</span> pcg32_random_r</span>
<span id="cb5-25"><a href="#cb5-25"></a>		oldstate <span class="kw">=</span> <span class="ot">@state</span></span>
<span id="cb5-26"><a href="#cb5-26"></a>		<span class="ot">@state</span> <span class="kw">=</span> (((oldstate <span class="kw">*</span> <span class="dv">6364136223846793005</span>) <span class="kw">%</span> <span class="cn">U64_MOD</span>) <span class="kw">+</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>			(<span class="ot">@inc</span> <span class="kw">|</span> <span class="dv">1</span>)) <span class="kw">%</span> <span class="cn">U64_MOD</span></span>
<span id="cb5-28"><a href="#cb5-28"></a>		xorshifted <span class="kw">=</span> (((oldstate <span class="kw">&gt;&gt;</span> <span class="dv">18</span>) <span class="kw">^</span> oldstate) <span class="kw">&gt;&gt;</span> <span class="dv">27</span>) <span class="kw">%</span> <span class="cn">U32_MOD</span></span>
<span id="cb5-29"><a href="#cb5-29"></a>		rot <span class="kw">=</span> oldstate <span class="kw">&gt;&gt;</span> <span class="dv">59</span></span>
<span id="cb5-30"><a href="#cb5-30"></a>		(xorshifted <span class="kw">&gt;&gt;</span> rot) <span class="kw">|</span> ((xorshifted <span class="kw">&lt;&lt;</span> ((<span class="kw">-</span>rot) <span class="kw">&amp;</span> <span class="dv">31</span>)) <span class="kw">%</span> <span class="cn">U32_MOD</span>)</span>
<span id="cb5-31"><a href="#cb5-31"></a>	<span class="cf">end</span></span>
<span id="cb5-32"><a href="#cb5-32"></a></span>
<span id="cb5-33"><a href="#cb5-33"></a>	<span class="cf">def</span> uniform32(range)</span>
<span id="cb5-34"><a href="#cb5-34"></a>		rand_excess <span class="kw">=</span> ((<span class="cn">U32_MAX</span> <span class="kw">%</span> range) <span class="kw">+</span> <span class="dv">1</span>) <span class="kw">%</span> range</span>
<span id="cb5-35"><a href="#cb5-35"></a>		rand_limit <span class="kw">=</span> <span class="cn">U32_MAX</span> <span class="kw">-</span> rand_excess</span>
<span id="cb5-36"><a href="#cb5-36"></a>		<span class="cf">while</span> ((x <span class="kw">=</span> <span class="dv">self</span><span class="at">.pcg32_random_r</span>) <span class="kw">&gt;</span> rand_limit)</span>
<span id="cb5-37"><a href="#cb5-37"></a>		<span class="cf">end</span></span>
<span id="cb5-38"><a href="#cb5-38"></a>		x <span class="kw">%</span> range</span>
<span id="cb5-39"><a href="#cb5-39"></a>	<span class="cf">end</span></span>
<span id="cb5-40"><a href="#cb5-40"></a><span class="cf">end</span></span>
<span id="cb5-41"><a href="#cb5-41"></a></span>
<span id="cb5-42"><a href="#cb5-42"></a><span class="cf">def</span> init_array(keys, has_key, rng)</span>
<span id="cb5-43"><a href="#cb5-43"></a>	j <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb5-44"><a href="#cb5-44"></a>	<span class="cf">for</span> i <span class="cf">in</span> <span class="dv">0</span><span class="kw">..</span>(<span class="cn">KEYS_TOTAL</span> <span class="kw">-</span> <span class="dv">1</span>)</span>
<span id="cb5-45"><a href="#cb5-45"></a>		j <span class="kw">+=</span> rng<span class="at">.uniform32</span>(<span class="dv">2</span>)</span>
<span id="cb5-46"><a href="#cb5-46"></a>		keys<span class="kw">[</span>i<span class="kw">]</span> <span class="kw">=</span> i <span class="kw">+</span> j</span>
<span id="cb5-47"><a href="#cb5-47"></a>	<span class="cf">end</span></span>
<span id="cb5-48"><a href="#cb5-48"></a></span>
<span id="cb5-49"><a href="#cb5-49"></a>	<span class="cf">if</span> has_key</span>
<span id="cb5-50"><a href="#cb5-50"></a>		keys<span class="kw">[</span>rng<span class="at">.uniform32</span>(<span class="cn">KEYS_TOTAL</span>)<span class="kw">]</span></span>
<span id="cb5-51"><a href="#cb5-51"></a>	<span class="cf">else</span></span>
<span id="cb5-52"><a href="#cb5-52"></a>		keys<span class="kw">[</span><span class="cn">KEYS_TOTAL</span> <span class="kw">-</span> <span class="dv">1</span><span class="kw">]</span> <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb5-53"><a href="#cb5-53"></a>	<span class="cf">end</span></span>
<span id="cb5-54"><a href="#cb5-54"></a><span class="cf">end</span></span>
<span id="cb5-55"><a href="#cb5-55"></a></span>
<span id="cb5-56"><a href="#cb5-56"></a><span class="cf">def</span> binary_search(keys, key, min, max)</span>
<span id="cb5-57"><a href="#cb5-57"></a>	list_size <span class="kw">=</span> (max <span class="kw">-</span> min) <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb5-58"><a href="#cb5-58"></a>	<span class="cf">if</span> (list_size <span class="kw">==</span> <span class="dv">0</span>)</span>
<span id="cb5-59"><a href="#cb5-59"></a>		<span class="cf">return</span> <span class="dv">nil</span></span>
<span id="cb5-60"><a href="#cb5-60"></a>	<span class="cf">end</span></span>
<span id="cb5-61"><a href="#cb5-61"></a></span>
<span id="cb5-62"><a href="#cb5-62"></a>	mid <span class="kw">=</span> (list_size <span class="kw">/</span> <span class="dv">2</span>) <span class="kw">+</span> min</span>
<span id="cb5-63"><a href="#cb5-63"></a></span>
<span id="cb5-64"><a href="#cb5-64"></a>	<span class="cf">if</span> (key <span class="kw">&lt;</span> keys<span class="kw">[</span>mid<span class="kw">]</span>)</span>
<span id="cb5-65"><a href="#cb5-65"></a>		binary_search(keys, key, min, mid <span class="kw">-</span> <span class="dv">1</span>)</span>
<span id="cb5-66"><a href="#cb5-66"></a>	<span class="cf">elsif</span> (key <span class="kw">&gt;</span> keys<span class="kw">[</span>mid<span class="kw">]</span>)</span>
<span id="cb5-67"><a href="#cb5-67"></a>		binary_search(keys, key, mid <span class="kw">+</span> <span class="dv">1</span>, max)</span>
<span id="cb5-68"><a href="#cb5-68"></a>	<span class="cf">else</span></span>
<span id="cb5-69"><a href="#cb5-69"></a>		mid</span>
<span id="cb5-70"><a href="#cb5-70"></a>	<span class="cf">end</span></span>
<span id="cb5-71"><a href="#cb5-71"></a><span class="cf">end</span></span>
<span id="cb5-72"><a href="#cb5-72"></a></span>
<span id="cb5-73"><a href="#cb5-73"></a><span class="co"># Begin program</span></span>
<span id="cb5-74"><a href="#cb5-74"></a></span>
<span id="cb5-75"><a href="#cb5-75"></a>rng <span class="kw">=</span> <span class="cn">PCG32</span><span class="at">.new</span>(<span class="bn">0x1234567890abcdef</span>, <span class="bn">0x1234567890abcdef</span>)</span>
<span id="cb5-76"><a href="#cb5-76"></a></span>
<span id="cb5-77"><a href="#cb5-77"></a><span class="co"># RNG self-test.</span></span>
<span id="cb5-78"><a href="#cb5-78"></a><span class="cf">if</span> (<span class="cn">ARGV</span> <span class="kw">==</span> <span class="kw">[</span><span class="st">&quot;rng&quot;</span><span class="kw">]</span>)</span>
<span id="cb5-79"><a href="#cb5-79"></a>	<span class="fu">puts</span> <span class="st">&quot;Running RNG self-test.&quot;</span></span>
<span id="cb5-80"><a href="#cb5-80"></a>	<span class="fu">puts</span> rng<span class="at">.pcg32_random_r</span></span>
<span id="cb5-81"><a href="#cb5-81"></a>	<span class="cf">for</span> n <span class="cf">in</span> <span class="dv">0</span><span class="kw">..</span><span class="dv">999999</span></span>
<span id="cb5-82"><a href="#cb5-82"></a>		rng<span class="at">.pcg32_random_r</span></span>
<span id="cb5-83"><a href="#cb5-83"></a>	<span class="cf">end</span></span>
<span id="cb5-84"><a href="#cb5-84"></a>	<span class="fu">puts</span> rng<span class="at">.pcg32_random_r</span></span>
<span id="cb5-85"><a href="#cb5-85"></a>	<span class="cf">for</span> n <span class="cf">in</span> <span class="dv">0</span><span class="kw">..</span><span class="dv">99</span></span>
<span id="cb5-86"><a href="#cb5-86"></a>		<span class="fu">puts</span> rng<span class="at">.uniform32</span>((<span class="cn">U32_MAX</span> <span class="kw">/</span> <span class="dv">2</span>) <span class="kw">+</span> (<span class="cn">U32_MAX</span> <span class="kw">/</span> <span class="dv">3</span>))</span>
<span id="cb5-87"><a href="#cb5-87"></a>	<span class="cf">end</span></span>
<span id="cb5-88"><a href="#cb5-88"></a>	<span class="cf">for</span> n <span class="cf">in</span> <span class="dv">0</span><span class="kw">..</span><span class="dv">9</span></span>
<span id="cb5-89"><a href="#cb5-89"></a>		has_key <span class="kw">=</span> rng<span class="at">.uniform32</span>(<span class="dv">2</span>) <span class="kw">==</span> <span class="dv">1</span></span>
<span id="cb5-90"><a href="#cb5-90"></a>		keys <span class="kw">=</span> <span class="kw">[]</span></span>
<span id="cb5-91"><a href="#cb5-91"></a>		key <span class="kw">=</span> init_array(keys, has_key, rng)</span>
<span id="cb5-92"><a href="#cb5-92"></a>		<span class="fu">puts</span> <span class="st">&quot;last number in array </span><span class="sc">#{</span>n<span class="sc">}</span><span class="st"> for key </span><span class="sc">#{</span>key<span class="sc">}</span><span class="st">: </span><span class="sc">#{</span>keys<span class="kw">[</span><span class="cn">KEYS_TOTAL</span> <span class="kw">-</span> <span class="dv">1</span><span class="kw">]</span><span class="sc">}</span><span class="st">&quot;</span></span>
<span id="cb5-93"><a href="#cb5-93"></a>	<span class="cf">end</span></span>
<span id="cb5-94"><a href="#cb5-94"></a>	<span class="fu">puts</span> <span class="st">&quot;Done.&quot;</span></span>
<span id="cb5-95"><a href="#cb5-95"></a>	<span class="fu">puts</span> <span class="st">&quot;END RUBY VERSION&quot;</span></span>
<span id="cb5-96"><a href="#cb5-96"></a>	<span class="fu">exit</span></span>
<span id="cb5-97"><a href="#cb5-97"></a><span class="cf">end</span></span>
<span id="cb5-98"><a href="#cb5-98"></a></span>
<span id="cb5-99"><a href="#cb5-99"></a>keys <span class="kw">=</span> <span class="kw">[]</span></span>
<span id="cb5-100"><a href="#cb5-100"></a></span>
<span id="cb5-101"><a href="#cb5-101"></a><span class="co"># Stress-test 'binary_search' method.</span></span>
<span id="cb5-102"><a href="#cb5-102"></a><span class="cf">for</span> i <span class="cf">in</span> <span class="dv">0</span><span class="kw">..</span><span class="dv">19</span></span>
<span id="cb5-103"><a href="#cb5-103"></a>	has_key <span class="kw">=</span> rng<span class="at">.uniform32</span>(<span class="dv">2</span>) <span class="kw">==</span> <span class="dv">1</span></span>
<span id="cb5-104"><a href="#cb5-104"></a>	key <span class="kw">=</span> init_array(keys, has_key, rng)</span>
<span id="cb5-105"><a href="#cb5-105"></a>	min <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb5-106"><a href="#cb5-106"></a>	max <span class="kw">=</span> <span class="cn">KEYS_TOTAL</span> <span class="kw">-</span> <span class="dv">1</span></span>
<span id="cb5-107"><a href="#cb5-107"></a>	mid <span class="kw">=</span> binary_search(keys, key, min, max)</span>
<span id="cb5-108"><a href="#cb5-108"></a>	<span class="fu">printf</span>(<span class="st">&quot;%02d - &quot;</span>, i <span class="kw">+</span> <span class="dv">1</span>)</span>
<span id="cb5-109"><a href="#cb5-109"></a>	<span class="cf">if</span> mid<span class="at">.nil?</span></span>
<span id="cb5-110"><a href="#cb5-110"></a>		<span class="fu">puts</span> <span class="st">&quot;key `</span><span class="sc">#{</span>key<span class="sc">}</span><span class="st">' not found.&quot;</span></span>
<span id="cb5-111"><a href="#cb5-111"></a>	<span class="cf">else</span></span>
<span id="cb5-112"><a href="#cb5-112"></a>		<span class="fu">puts</span> <span class="st">&quot;key `</span><span class="sc">#{</span>key<span class="sc">}</span><span class="st">' found at keys[</span><span class="sc">#{</span>mid<span class="sc">}</span><span class="st">].&quot;</span></span>
<span id="cb5-113"><a href="#cb5-113"></a>	<span class="cf">end</span></span>
<span id="cb5-114"><a href="#cb5-114"></a><span class="cf">end</span></span>
<span id="cb5-115"><a href="#cb5-115"></a><span class="fu">puts</span> <span class="st">&quot;END RUBY VERSION&quot;</span></span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>binary-search.rb</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/binary-search.rb"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/binary-search.rb" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>This version, like the Haskell version, tries to follow the C version as
much as possible. One drawback of this version is that because Ruby does
not support fixed-width integers, we have to make liberal use of the
modulo operator <code class="verbatim">%</code> to emulate integer overflow. We could just do a
bitwise AND (<code class="verbatim">&amp;</code>) with a mask, but that would risk increased verbosity.</p>
<h2 id="haskell-version">Haskell Version</h2>
<div class="code-and-raw">
<div class="sourceCode" id="cb6" data-startFrom="1"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">-- LICENSE: PUBLIC DOMAIN</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">--</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">-- Compile with `ghc --make -Wall -Werror -O2 -dynamic -o binary-search-hs</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">-- binary-search.hs'. For better conformance with the C and Ruby versions, we</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">-- use snake_case instead of camelCase wherever there is a direct parallel.</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">--</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">-- Interact with `ghci path/to/this/file`.</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="co">--</span></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="co">-- Usage: just execute the binary as-is without any arguments. To test the RNG,</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">-- call with the argument &quot;rng&quot;.</span></span>
<span id="cb6-13"><a href="#cb6-13"></a></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb6-15"><a href="#cb6-15"></a></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="kw">import</span> <span class="dt">Data.Bits</span></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="kw">import</span> <span class="dt">Data.Word</span></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="kw">import</span> <span class="dt">System.Environment</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="kw">import</span> <span class="dt">System.Exit</span></span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="kw">import</span> <span class="dt">Text.Printf</span></span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="ot">u32_max ::</span> <span class="dt">Word32</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>u32_max <span class="ot">=</span> <span class="bn">0xffffffff</span></span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="ot">keys_total ::</span> <span class="dt">Int</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>keys_total <span class="ot">=</span> <span class="dv">1000000</span></span>
<span id="cb6-28"><a href="#cb6-28"></a></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="kw">data</span> <span class="dt">PCG32</span> <span class="ot">=</span> <span class="dt">PCG32</span></span>
<span id="cb6-30"><a href="#cb6-30"></a>  {<span class="ot"> state ::</span> <span class="dt">Word64</span></span>
<span id="cb6-31"><a href="#cb6-31"></a>  ,<span class="ot"> inc ::</span> <span class="dt">Word64</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>  }</span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a><span class="ot">pcg32_random_r ::</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> (<span class="dt">Word32</span>, <span class="dt">PCG32</span>)</span>
<span id="cb6-35"><a href="#cb6-35"></a>pcg32_random_r rng<span class="op">@</span><span class="dt">PCG32</span>{<span class="op">..</span>} <span class="ot">=</span> (result, rng {state <span class="ot">=</span> state'})</span>
<span id="cb6-36"><a href="#cb6-36"></a>  <span class="kw">where</span></span>
<span id="cb6-37"><a href="#cb6-37"></a><span class="ot">  state' ::</span> <span class="dt">Word64</span></span>
<span id="cb6-38"><a href="#cb6-38"></a>  state' <span class="ot">=</span> state <span class="op">*</span> <span class="dv">6364136223846793005</span> <span class="op">+</span> (inc <span class="op">.|.</span> <span class="dv">1</span>)</span>
<span id="cb6-39"><a href="#cb6-39"></a><span class="ot">  xorshifted ::</span> <span class="dt">Word32</span></span>
<span id="cb6-40"><a href="#cb6-40"></a>  xorshifted <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> shiftR (xor (shiftR state <span class="dv">18</span>) state) <span class="dv">27</span></span>
<span id="cb6-41"><a href="#cb6-41"></a><span class="ot">  rot ::</span> <span class="dt">Word32</span></span>
<span id="cb6-42"><a href="#cb6-42"></a>  rot <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> shiftR state <span class="dv">59</span></span>
<span id="cb6-43"><a href="#cb6-43"></a><span class="ot">  result ::</span> <span class="dt">Word32</span></span>
<span id="cb6-44"><a href="#cb6-44"></a>  result <span class="ot">=</span> <span class="fu">fromIntegral</span></span>
<span id="cb6-45"><a href="#cb6-45"></a>    <span class="op">$</span> (shiftR xorshifted <span class="op">$</span> <span class="fu">fromIntegral</span> rot)</span>
<span id="cb6-46"><a href="#cb6-46"></a>      <span class="op">.|.</span> (shiftL xorshifted <span class="op">$</span> <span class="fu">fromIntegral</span> ((<span class="op">-</span>rot) <span class="op">.&amp;.</span> <span class="dv">31</span>))</span>
<span id="cb6-47"><a href="#cb6-47"></a></span>
<span id="cb6-48"><a href="#cb6-48"></a><span class="ot">uniform32 ::</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> (<span class="dt">Word32</span>, <span class="dt">PCG32</span>)</span>
<span id="cb6-49"><a href="#cb6-49"></a>uniform32 <span class="fu">range</span> rng <span class="ot">=</span> find_within_range rng</span>
<span id="cb6-50"><a href="#cb6-50"></a>  <span class="kw">where</span></span>
<span id="cb6-51"><a href="#cb6-51"></a><span class="ot">  rand_excess ::</span> <span class="dt">Word32</span></span>
<span id="cb6-52"><a href="#cb6-52"></a>  rand_excess <span class="ot">=</span> <span class="fu">mod</span> ((<span class="fu">mod</span> u32_max <span class="fu">range</span>) <span class="op">+</span> <span class="dv">1</span>) <span class="fu">range</span></span>
<span id="cb6-53"><a href="#cb6-53"></a><span class="ot">  rand_limit ::</span> <span class="dt">Word32</span></span>
<span id="cb6-54"><a href="#cb6-54"></a>  rand_limit <span class="ot">=</span> u32_max <span class="op">-</span> rand_excess</span>
<span id="cb6-55"><a href="#cb6-55"></a>  find_within_range rng' <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&gt;</span> rand_limit</span>
<span id="cb6-56"><a href="#cb6-56"></a>    <span class="kw">then</span> find_within_range rng''</span>
<span id="cb6-57"><a href="#cb6-57"></a>    <span class="kw">else</span> (<span class="fu">mod</span> x <span class="fu">range</span>, rng'')</span>
<span id="cb6-58"><a href="#cb6-58"></a>    <span class="kw">where</span></span>
<span id="cb6-59"><a href="#cb6-59"></a>    (x, rng'') <span class="ot">=</span> pcg32_random_r rng'</span>
<span id="cb6-60"><a href="#cb6-60"></a></span>
<span id="cb6-61"><a href="#cb6-61"></a><span class="ot">init_array ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> ([<span class="dt">Word32</span>], <span class="dt">Word32</span>, <span class="dt">PCG32</span>)</span>
<span id="cb6-62"><a href="#cb6-62"></a>init_array keys_size has_key rng0 <span class="ot">=</span> (keys, key, rng3)</span>
<span id="cb6-63"><a href="#cb6-63"></a>  <span class="kw">where</span></span>
<span id="cb6-64"><a href="#cb6-64"></a>  (keys', rng1) <span class="ot">=</span> genKeysList [] <span class="dv">0</span> <span class="dv">0</span> rng0</span>
<span id="cb6-65"><a href="#cb6-65"></a>  <span class="co">-- Need to reverse the list, because Haskell (like all Lispy languages?)</span></span>
<span id="cb6-66"><a href="#cb6-66"></a>  <span class="co">-- builds a list backwards when using the cons (:) operator.</span></span>
<span id="cb6-67"><a href="#cb6-67"></a>  keys <span class="ot">=</span> <span class="fu">reverse</span> keys'</span>
<span id="cb6-68"><a href="#cb6-68"></a><span class="ot">  genKeysList ::</span> [<span class="dt">Word32</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">PCG32</span> <span class="ot">-&gt;</span> ([<span class="dt">Word32</span>], <span class="dt">PCG32</span>)</span>
<span id="cb6-69"><a href="#cb6-69"></a>  genKeysList arr i j0 rng <span class="ot">=</span> <span class="kw">if</span> i <span class="op">&lt;</span> keys_size</span>
<span id="cb6-70"><a href="#cb6-70"></a>    <span class="kw">then</span> genKeysList ((i' <span class="op">+</span> j2')<span class="op">:</span>arr) (i <span class="op">+</span> <span class="dv">1</span>) j2 rng'</span>
<span id="cb6-71"><a href="#cb6-71"></a>    <span class="kw">else</span> (arr, rng)</span>
<span id="cb6-72"><a href="#cb6-72"></a>    <span class="kw">where</span></span>
<span id="cb6-73"><a href="#cb6-73"></a>    i' <span class="ot">=</span> <span class="fu">fromIntegral</span> i</span>
<span id="cb6-74"><a href="#cb6-74"></a>    j2' <span class="ot">=</span> <span class="fu">fromIntegral</span> j2</span>
<span id="cb6-75"><a href="#cb6-75"></a>    (j1, rng') <span class="ot">=</span> uniform32 <span class="dv">2</span> rng</span>
<span id="cb6-76"><a href="#cb6-76"></a>    j2 <span class="ot">=</span> j0 <span class="op">+</span> <span class="fu">fromIntegral</span> j1</span>
<span id="cb6-77"><a href="#cb6-77"></a>  (key, rng3) <span class="ot">=</span> <span class="kw">if</span> has_key</span>
<span id="cb6-78"><a href="#cb6-78"></a>    <span class="kw">then</span></span>
<span id="cb6-79"><a href="#cb6-79"></a>      <span class="kw">let</span></span>
<span id="cb6-80"><a href="#cb6-80"></a>        (idx, rng2) <span class="ot">=</span> uniform32 (<span class="fu">fromIntegral</span> keys_total) rng1</span>
<span id="cb6-81"><a href="#cb6-81"></a>      <span class="kw">in</span></span>
<span id="cb6-82"><a href="#cb6-82"></a>      (keys<span class="op">!!</span>(<span class="fu">fromIntegral</span> idx), rng2)</span>
<span id="cb6-83"><a href="#cb6-83"></a>    <span class="kw">else</span> (keys<span class="op">!!</span>(keys_total <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> <span class="dv">1</span>, rng1)</span>
<span id="cb6-84"><a href="#cb6-84"></a></span>
<span id="cb6-85"><a href="#cb6-85"></a><span class="co">-- We use min' and max' because the non-apostrophe versions name-clash with</span></span>
<span id="cb6-86"><a href="#cb6-86"></a><span class="co">-- Prelude's own functions. We could hide Prelude's imports, but that seems too</span></span>
<span id="cb6-87"><a href="#cb6-87"></a><span class="co">-- roundabout.</span></span>
<span id="cb6-88"><a href="#cb6-88"></a><span class="ot">binary_search ::</span> [<span class="dt">Word32</span>] <span class="ot">-&gt;</span> <span class="dt">Word32</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb6-89"><a href="#cb6-89"></a>binary_search keys key min' max'</span>
<span id="cb6-90"><a href="#cb6-90"></a>  <span class="op">|</span> list_size <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb6-91"><a href="#cb6-91"></a>  <span class="op">|</span> key <span class="op">&lt;</span> keys<span class="op">!!</span>mid <span class="ot">=</span> binary_search keys key min' (mid <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb6-92"><a href="#cb6-92"></a>  <span class="op">|</span> key <span class="op">&gt;</span> keys<span class="op">!!</span>mid <span class="ot">=</span> binary_search keys key (mid <span class="op">+</span> <span class="dv">1</span>) max'</span>
<span id="cb6-93"><a href="#cb6-93"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Just</span> mid</span>
<span id="cb6-94"><a href="#cb6-94"></a>  <span class="kw">where</span></span>
<span id="cb6-95"><a href="#cb6-95"></a>  list_size <span class="ot">=</span> (max' <span class="op">-</span> min') <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-96"><a href="#cb6-96"></a>  mid <span class="ot">=</span> (<span class="fu">div</span> list_size <span class="dv">2</span>) <span class="op">+</span> min'</span>
<span id="cb6-97"><a href="#cb6-97"></a></span>
<span id="cb6-98"><a href="#cb6-98"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-99"><a href="#cb6-99"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-100"><a href="#cb6-100"></a>  <span class="kw">let</span></span>
<span id="cb6-101"><a href="#cb6-101"></a>    rng0 <span class="ot">=</span> <span class="dt">PCG32</span></span>
<span id="cb6-102"><a href="#cb6-102"></a>      { state <span class="ot">=</span> <span class="bn">0x1234567890abcdef</span></span>
<span id="cb6-103"><a href="#cb6-103"></a>      , inc <span class="ot">=</span> <span class="bn">0x1234567890abcdef</span></span>
<span id="cb6-104"><a href="#cb6-104"></a>      }</span>
<span id="cb6-105"><a href="#cb6-105"></a>  args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb6-106"><a href="#cb6-106"></a>  when (args <span class="op">==</span> [<span class="st">&quot;rng&quot;</span>]) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-107"><a href="#cb6-107"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;Running RNG self-test&quot;</span></span>
<span id="cb6-108"><a href="#cb6-108"></a>    <span class="kw">let</span></span>
<span id="cb6-109"><a href="#cb6-109"></a>      (num0, rng1) <span class="ot">=</span> pcg32_random_r rng0</span>
<span id="cb6-110"><a href="#cb6-110"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> num0</span>
<span id="cb6-111"><a href="#cb6-111"></a>    rng2 <span class="ot">&lt;-</span> foldM warmupRng rng1 [<span class="dv">0</span><span class="op">..</span><span class="dv">999999</span><span class="ot">::</span><span class="dt">Int</span>]</span>
<span id="cb6-112"><a href="#cb6-112"></a>    <span class="kw">let</span></span>
<span id="cb6-113"><a href="#cb6-113"></a>      (num1, rng3) <span class="ot">=</span> pcg32_random_r rng2</span>
<span id="cb6-114"><a href="#cb6-114"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> num1</span>
<span id="cb6-115"><a href="#cb6-115"></a>    rng4 <span class="ot">&lt;-</span> foldM testUniform32 rng3 [<span class="dv">0</span><span class="op">..</span><span class="dv">99</span><span class="ot">::</span><span class="dt">Int</span>]</span>
<span id="cb6-116"><a href="#cb6-116"></a>    _ <span class="ot">&lt;-</span> foldM testArray rng4 [<span class="dv">0</span><span class="op">..</span><span class="dv">9</span><span class="ot">::</span><span class="dt">Int</span>]</span>
<span id="cb6-117"><a href="#cb6-117"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;Done.&quot;</span></span>
<span id="cb6-118"><a href="#cb6-118"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;END HASKELL VERSION&quot;</span></span>
<span id="cb6-119"><a href="#cb6-119"></a>    exitSuccess</span>
<span id="cb6-120"><a href="#cb6-120"></a>  _ <span class="ot">&lt;-</span> foldM testBinarySearch rng0 [<span class="dv">0</span><span class="op">..</span><span class="dv">19</span><span class="ot">::</span><span class="dt">Int</span>]</span>
<span id="cb6-121"><a href="#cb6-121"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;END HASKELL VERSION&quot;</span></span>
<span id="cb6-122"><a href="#cb6-122"></a>  <span class="kw">where</span></span>
<span id="cb6-123"><a href="#cb6-123"></a>  warmupRng rng _ <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> <span class="fu">snd</span> <span class="op">$</span> pcg32_random_r rng</span>
<span id="cb6-124"><a href="#cb6-124"></a>  testUniform32 rng _ <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-125"><a href="#cb6-125"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> num</span>
<span id="cb6-126"><a href="#cb6-126"></a>    <span class="fu">return</span> rng'</span>
<span id="cb6-127"><a href="#cb6-127"></a>    <span class="kw">where</span></span>
<span id="cb6-128"><a href="#cb6-128"></a>    (num, rng') <span class="ot">=</span> uniform32 (<span class="fu">div</span> u32_max <span class="dv">2</span> <span class="op">+</span> <span class="fu">div</span> u32_max <span class="dv">3</span>) rng</span>
<span id="cb6-129"><a href="#cb6-129"></a>  testArray rng0 i <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-130"><a href="#cb6-130"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;last number in array &quot;</span></span>
<span id="cb6-131"><a href="#cb6-131"></a>      <span class="op">++</span> <span class="fu">show</span> i</span>
<span id="cb6-132"><a href="#cb6-132"></a>      <span class="op">++</span> <span class="st">&quot; for key &quot;</span></span>
<span id="cb6-133"><a href="#cb6-133"></a>      <span class="op">++</span> <span class="fu">show</span> key</span>
<span id="cb6-134"><a href="#cb6-134"></a>      <span class="op">++</span> <span class="st">&quot;: &quot;</span></span>
<span id="cb6-135"><a href="#cb6-135"></a>      <span class="op">++</span> <span class="fu">show</span> (keys<span class="op">!!</span>(keys_total <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb6-136"><a href="#cb6-136"></a>    <span class="fu">return</span> rng2</span>
<span id="cb6-137"><a href="#cb6-137"></a>    <span class="kw">where</span></span>
<span id="cb6-138"><a href="#cb6-138"></a>    (res, rng1) <span class="ot">=</span> uniform32 <span class="dv">2</span> rng0</span>
<span id="cb6-139"><a href="#cb6-139"></a>    has_key <span class="ot">=</span> res <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb6-140"><a href="#cb6-140"></a>    (keys, key, rng2) <span class="ot">=</span> init_array keys_total has_key rng1</span>
<span id="cb6-141"><a href="#cb6-141"></a>  testBinarySearch rng0 i <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-142"><a href="#cb6-142"></a>    printf <span class="st">&quot;%02d - &quot;</span> (i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-143"><a href="#cb6-143"></a>    <span class="kw">case</span> foundMid <span class="kw">of</span></span>
<span id="cb6-144"><a href="#cb6-144"></a>      <span class="dt">Just</span> mid <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;key `&quot;</span></span>
<span id="cb6-145"><a href="#cb6-145"></a>        <span class="op">++</span> <span class="fu">show</span> key</span>
<span id="cb6-146"><a href="#cb6-146"></a>        <span class="op">++</span> <span class="st">&quot;' found at keys[&quot;</span></span>
<span id="cb6-147"><a href="#cb6-147"></a>        <span class="op">++</span> <span class="fu">show</span> mid</span>
<span id="cb6-148"><a href="#cb6-148"></a>        <span class="op">++</span> <span class="st">&quot;].&quot;</span></span>
<span id="cb6-149"><a href="#cb6-149"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;key `&quot;</span></span>
<span id="cb6-150"><a href="#cb6-150"></a>        <span class="op">++</span> <span class="fu">show</span> key</span>
<span id="cb6-151"><a href="#cb6-151"></a>        <span class="op">++</span> <span class="st">&quot;' not found.&quot;</span></span>
<span id="cb6-152"><a href="#cb6-152"></a>    <span class="fu">return</span> rng2</span>
<span id="cb6-153"><a href="#cb6-153"></a>    <span class="kw">where</span></span>
<span id="cb6-154"><a href="#cb6-154"></a>    (res, rng1) <span class="ot">=</span> uniform32 <span class="dv">2</span> rng0</span>
<span id="cb6-155"><a href="#cb6-155"></a>    has_key <span class="ot">=</span> res <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb6-156"><a href="#cb6-156"></a>    (keys, key, rng2) <span class="ot">=</span> init_array keys_total has_key rng1</span>
<span id="cb6-157"><a href="#cb6-157"></a>    min' <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb6-158"><a href="#cb6-158"></a>    max' <span class="ot">=</span> keys_total <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb6-159"><a href="#cb6-159"></a>    foundMid <span class="ot">=</span> binary_search keys key min' max'</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>binary-search.hs</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/binary-search.hs"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/binary-search.hs" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>It pained me not to make use of Haskell’s much faster, efficient <code class="verbatim">Array</code>
data structure instead of plain lists (that are constructed with the
square brackets <code class="verbatim">[]</code>). And, I have to admit that it is written in a
strange style; I’ve preserved the names of the variables from C and Ruby
where I could, even though mixing snake_case with camelCase results in
utter ugliness. I also restrained myself from using the <code class="verbatim">State</code> monad
for keeping track of <code class="verbatim">PCG32</code>’s state. For you non-Haskellers, that means
that I manually passed around RNG state (as you can see with <code class="verbatim">rng0</code>,
<code class="verbatim">rng1</code>, <code class="verbatim">rng2</code>, etc.) as arguments and return values, because I did not
want to place another barrier against quickly grasping the code. Do you
really want monad transformers in a “naive” implementation?<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>The most immediate effect to me when writing the Haskell version was
just how stateful the <code class="verbatim">uniform32()</code> and <code class="verbatim">init_array()</code> functions were.
The C/Ruby brethren perform lots of variable mutation in those parts,
and are consequently difficult to understand from a <em>pure</em> (type system)
perspective. All of the silent type promotions in C were blatantly
exposed by the Glasgow Haskell Compiler (GHC), making it necessary for
me to include all of those explicit <code class="verbatim">fromIntegral</code> type promotions
myself in <code class="verbatim">pcg32_random_r</code> and <code class="verbatim">init_array</code>.</p>
<p>But even with all of these explicit conversions and the un-idiomatic
Haskell style (excluding coding style), I find the Haskell version much
easier to understand. Just compare how clean <code class="verbatim">binary_search</code> looks in
Haskell versus the other ones! And the fact that you can basically
define nested functions/methods with the <code class="verbatim">where</code> clause makes
hole-driven development a piece of cake.</p>
<h1 id="conclusion-and-hopes">Conclusion and Hopes</h1>
<p>I hope you’ve enjoyed looking at the various implementations of binary
search. Binary search is certainly something you can write on your own,
although getting the surrounding technicalities correct can be a chore
— but isn’t that always the case when trying to obvserve the behavior
of an algorithm in practice? You can look at the cute 10 or 15-line
pseudocode on Wikipedia all day, but how can you be sure that it works?
This focus on <strong>real world examples</strong> has been a driving principle behind
all of my blog posts, and I hope it has helped you understand the
algorithm better.</p>
<p>Binary search is something you can apply in real life, too. For me, I
came into contact with it again when I learned about <code class="verbatim">git bisect</code>. I
personally try to use binary search myself when I code; for example, if
a large block of code does not work, I delete large chunks out, making
the deletions ever finer, until I get to the source of the problem. You
can think of these examples as binary search, where the key is the (as
yet unknown) bad commit or line of code you have to fix. You can be your
own algorithm! Isn’t that cool?</p>
<p>Thanks for reading, and happy hacking!</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>It’s like in the children’s
<a href="http://en.wikipedia.org/wiki/Chinese_whispers">“Telephone”</a>
game, where the error of one person gets magnified at every step,
until the end when the message gets so garbled up it becomes
comical.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>“Hole-driven-development”, as I like to call it, is a top-down
approach to development. You first define the larger pieces, and
continuously define the smaller sub-pieces, until you reach
atomic pieces (those pieces which cannot be further sub-divided).
You might have noticed that this style of writing code has an
eerie parallel to the whole (no pun intended!) discussion about
binary subdivision, and so forth.</p>
<p>As an aside, in the Haskell community, <em>hole-driven Haskell</em>
takes the same approach, but first you define the behaviors of
the functions through its type signatures, and leave the
implementation details undefined. This way, you can use the
compiler’s type system to help you define what you want as you
go; this is certainly a step up from <em>unassisted</em> hole-driven
development that we are doing with the pseudocode here.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The condition <code class="verbatim">first_index &gt; last_index</code> might not make sense.
This was the pseudocode on Wikipedia at the time I wrote this,
and it didn’t make sense to me at first. But think of it this
way: binary search involves division of the list into halves,
repeatedly. So <code class="verbatim">first_index</code> and <code class="verbatim">last_index</code> get closer and
closer to each other. The point is that the distance between
these two markers will close, shrinking the list into smaller and
smaller subparts. We can’t simply check if these two points meet,
by writing <code class="verbatim">first_index =</code> last_index=, because of the base case
of a 1-element list. Such a list will have <code class="verbatim">first_index</code> as 0,
and the <code class="verbatim">last_index</code> as also 0 — because there is only 1 index!
In this case, the condition <code class="verbatim">first_index =</code> last_index= to check
for an empty list is inadequate.</p>
<p>If you look at how we call <code class="verbatim">binary_search()</code> again in lines 15
and 17, you will notice that the new definitions of <code class="verbatim">first_index</code>
and <code class="verbatim">last_index</code> depend on <code class="verbatim">middle_index</code>, and it’s this
interplay with <code class="verbatim">middle_index</code> that forces <code class="verbatim">last_index</code> to
eventually become smaller than <code class="verbatim">first_index</code>. If you work out the
algorithm through some small cases, you will see this happen
eventually.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Linear search does have the advantage that, on a sorted list, it
can take advantage of branch prediction. This is because the
<code class="verbatim">if/else</code> test will <em>always go in one direction</em>, until when we
get a match or when the element considered is greater than the
search key. But in the long run as you increase the search space,
binary search will beat linear search hands down.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>However, be mindful to the fact that binary search relies on the
input list being sorted. Sorting a list itself is a fundamental
problem in computer science, and there are numerous sorting
algorithms as well as data structures that make such sorting more
amenable. In the real world, I think 90% of your time is going to
be spent sorting the list first, by which time the speed benefits
of binary search probably won’t hold much influence. If the
search space is always small, you could easily get away with
linear search — why bother adding complexity where you don’t
need it?<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>You could trivially add on a proper command-line argument
handling mechanism. In particular, <code class="verbatim">KEYS_TOTAL</code> is dying to be
decoupled from the program’s internals — but I leave that as an
exercise to you. (Hint: use a command-line option parsing
library!)<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>MELISSA E. O’NEILL (2009). The Genuine Sieve of Eratosthenes.
Journal of Functional Programming, 19, pp 95-106.
<a href="doi:10.1017/S0956796808007004">doi:10.1017/S0956796808007004</a>.
<a href="http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">Online draft version</a>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>What if I had indeed made use of the <code class="verbatim">State</code> monad, you ask?
Well, first I wouldn’t need to pass in, or get back, the RNG
state variables. I would just run the RNG-state-changing
functions <em>inside</em> the <code class="verbatim">State</code> monad (actually, probably the
<code class="verbatim">StateT</code> monad transformer as we’re in the <code class="verbatim">IO</code> monad anyway), to
<code class="verbatim">get=/=put</code> the RNG states to read/write those values.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

		</div>

		<div id="footer">
			<img src="../favicon.png" id="brand-icon">
			<p>Copyright (C) 2013-2024 Linus Arver. All rights reserved.</p>
			<a href="https://github.com/listx/listx_blog">Site</a>
			<a href="https://github.com/listx/listx.github.io">generated</a>
			with
			<a href="https://jaspervdj.be/hakyll">Hakyll</a>
			and
			<a href="http://sebastiaanvisser.github.com/clay">Clay</a>.
			<br>
			<a href="../atom.xml">Atom feed</a>
		</div>
	</body>
</html>
