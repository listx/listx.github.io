<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Linus’s Blog - Programming Puzzle: Game Button Sequence Recognizer</title>
		<link rel="stylesheet" href="../css/base.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Serif+Pro">
		<link rel="shortcut icon" type="image/png" href="../favicon.png">
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="../misc.js"></script>
		<!-- https://github.com/mreid/markreidname-hakyll/blob/master/_templates/mathjax.html -->
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		extensions: ["tex2jax.js"],
		jax: ["input/TeX", "output/HTML-CSS"],
		tex2jax: {
			inlineMath: [ ["\\(","\\)"] ],
			displayMath: [ ["\\[","\\]"] ],
			processEscapes: true
		},
		TeX: { equationNumbers: { autoNumber: "AMS" } },
		"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>

	</head>
	<body>
		<div id="header">
			<a href="../">funloop.org</a>
			|
			<a href="../about.html">About</a>
		</div>

		<div id="sticky-title">
			<h1 class="center" id="page-title">Programming Puzzle: Game Button Sequence Recognizer</h1>
		</div>

		<div id="content">
			<div class="info center">
	<a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-02-24-puzzle-game-button-recognizer.org" title="History"><code class="date">2015-02-24</code></a>
	<br>
	<a title="All pages tagged 'programming'." href="../tag/programming.html" rel="tag">programming</a>, <a title="All pages tagged 'haskell'." href="../tag/haskell.html" rel="tag">haskell</a>, <a title="All pages tagged 'ruby'." href="../tag/ruby.html" rel="tag">ruby</a>
</div>

<p>So just yesterday, I did a live coding interview. Looking back, the
problem I was presented with was very simple, but true to my usual
nervous self, I over-analzyed the problem — completely missing the
point and needlessly complicating things. In an effort to redeem myself,
I thought about the problem again and even went out as to write tests
for it, in both Ruby and Haskell. If you want to have a crack at the
problem yourself, be conservative about scrolling down the page! Without
further ado, I present the problem to you.</p>
<h1 id="the-problem">The Problem</h1>
<p>You are a game engine API writer. You need to implement a mechanism that
allows your developers to store and retrieve game moves based on the
input to the game engine. The two functions for this mechanism should be
named <code class="verbatim">register()</code> and <code class="verbatim">on_button()</code>.</p>
<p><code class="verbatim">register()</code> should take a named button sequence, and store it into the
database of all named sequences. A single named sequence might look like
this: <code class="verbatim">(["down", "forward", "punch"], "hadoken")</code>.</p>
<p><code class="verbatim">on_button()</code> should take a single key, and then return all named
sequences that match the ones in the database. E.g.,
<code class="verbatim">on_button("punch")</code> should return <code class="verbatim">"hadoken"</code> if the previous two
inputs were <code class="verbatim">"down"</code> and <code class="verbatim">"forward"</code>.</p>
<h2 id="some-constraints">Some Constraints</h2>
<h3 id="multiple-sequences">Multiple Sequences</h3>
<p>Because our API is flexible, we allow <em>multiple</em> named sequences with
the <em>same sequence</em>. Thus, you can expect something like this:</p>
<pre class="example"><code>register([&quot;up&quot;, &quot;punch&quot;], &quot;uppercut&quot;)
register([&quot;up&quot;, &quot;punch&quot;], &quot;uppercut_2&quot;)
on_button(&quot;up&quot;)        # no result
on_button(&quot;punch&quot;)     # [&quot;uppercut&quot;, &quot;uppercut_2&quot;]
</code></pre>
<p>. You don’t have to worry about multiple named sequences with the same
sequence and also the same name — we will worry about this “exact
duplicate” situation in a later version of our API.</p>
<h3 id="input-history">Input History</h3>
<p>You might have noticed that <code class="verbatim">on_button()</code> depends on the input history
of whatever buttons were <em>previously</em> entered into the game. Because of
this, you can alternatively write an <code class="verbatim">on_buttons()</code> function (plural
with an “s”) that takes the history of buttons as input; this way you
don’t have to silently depend on the global state of input history.</p>
<h1 id="my-nervous-wreck-solution">My Nervous-Wreck Solution</h1>
<p>I decided to use pure Haskell code in the actual interview. The code I
wrote had the general idea, but it was a big failure because it
performed a naive, custom search without any thought given to data
structures. I actually went back and revised the code to make it compile
and work <em>after</em> the interview was over; here it is in all its glory:</p>
<div class="code-and-raw">
<div class="sourceCode" id="cb2" data-startFrom="1"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">type</span> <span class="dt">ButtonSeqDB</span> <span class="ot">=</span> [(<span class="dt">ButtonSeq</span>, <span class="dt">Name</span>)]</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">type</span> <span class="dt">ButtonSeq</span> <span class="ot">=</span> [<span class="dt">String</span>]</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">-- Default DB of button sequences.</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="ot">buttonSeqDB ::</span> <span class="dt">ButtonSeqDB</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>buttonSeqDB <span class="ot">=</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  [ ([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;hadoken&quot;</span>)</span>
<span id="cb2-11"><a href="#cb2-11"></a>  , ([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;charger&quot;</span>)</span>
<span id="cb2-12"><a href="#cb2-12"></a>  , ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut&quot;</span>)</span>
<span id="cb2-13"><a href="#cb2-13"></a>  ]</span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="ot">register ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>register <span class="fu">sequence</span> name db</span>
<span id="cb2-17"><a href="#cb2-17"></a>  <span class="op">|</span> <span class="fu">null</span> <span class="fu">sequence</span> <span class="ot">=</span> db</span>
<span id="cb2-18"><a href="#cb2-18"></a>  <span class="op">|</span> alreadyExists <span class="ot">=</span> db</span>
<span id="cb2-19"><a href="#cb2-19"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (<span class="fu">sequence</span>, name) <span class="op">:</span> db</span>
<span id="cb2-20"><a href="#cb2-20"></a>  <span class="kw">where</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>  alreadyExists <span class="ot">=</span> <span class="fu">elem</span> (<span class="fu">sequence</span>, name) db</span>
<span id="cb2-22"><a href="#cb2-22"></a></span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="ot">onButtons ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]</span>
<span id="cb2-24"><a href="#cb2-24"></a>onButtons buttonHist db <span class="ot">=</span> <span class="fu">map</span> <span class="fu">snd</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>  <span class="op">.</span> <span class="fu">fst</span></span>
<span id="cb2-26"><a href="#cb2-26"></a>  <span class="op">.</span> <span class="fu">foldl</span> step ([], db)</span>
<span id="cb2-27"><a href="#cb2-27"></a>  <span class="op">$</span> <span class="fu">reverse</span> buttonHist</span>
<span id="cb2-28"><a href="#cb2-28"></a>  <span class="kw">where</span></span>
<span id="cb2-29"><a href="#cb2-29"></a>  step acc<span class="op">@</span>(foundSoFar, dbRem) button</span>
<span id="cb2-30"><a href="#cb2-30"></a>    <span class="op">|</span> <span class="fu">null</span> remaining <span class="ot">=</span> acc</span>
<span id="cb2-31"><a href="#cb2-31"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>      ( foundSoFar <span class="op">++</span> entriesComplete</span>
<span id="cb2-33"><a href="#cb2-33"></a>      , dbRem'</span>
<span id="cb2-34"><a href="#cb2-34"></a>      )</span>
<span id="cb2-35"><a href="#cb2-35"></a>    <span class="kw">where</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>    remaining <span class="ot">=</span> <span class="fu">filter</span> ((<span class="op">==</span>button) <span class="op">.</span> <span class="fu">last</span> <span class="op">.</span> <span class="fu">fst</span>)</span>
<span id="cb2-37"><a href="#cb2-37"></a>      <span class="op">$</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span> <span class="op">.</span> <span class="fu">fst</span>) dbRem</span>
<span id="cb2-38"><a href="#cb2-38"></a>    dbRem' <span class="ot">=</span> <span class="fu">map</span> (\(a, b) <span class="ot">-&gt;</span> (<span class="fu">init</span> a, b)) remaining</span>
<span id="cb2-39"><a href="#cb2-39"></a>    entriesComplete <span class="ot">=</span> <span class="fu">filter</span> (<span class="fu">null</span> <span class="op">.</span> <span class="fu">fst</span>) dbRem'</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>interview_ver.hs</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/game-button-seq/interview_ver.hs"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/game-button-seq/interview_ver.hs" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>. I have to admit, the <code class="verbatim">step</code> function in <code class="verbatim">onButtons</code> is essentially
unreadable. But it does work:</p>
<pre class="example"><code>$ ghci code/toy/game-button-seq/interview_ver.hs
GHCi, version 7.8.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( code/toy/game-button-seq/interview_ver.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; onButtons [&quot;down&quot;, &quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;] buttonSeqDB
[&quot;charger&quot;,&quot;hadoken&quot;]
</code></pre>
<p>.</p>
<p>Anyway, I will explain the behavior of the code. The first thing to
notice is that we feed into <code class="verbatim">step</code> the <em>reversed</em> list of <code class="verbatim">buttonHist</code>,
so that we examine the button press history, from newest to oldest. So
we look at the just-pressed-button, then the one before that, and the
one before, etc, backwards up the history.</p>
<p>As we look at each <code class="verbatim">button</code>, we use it to filter out all known
sequences. This filtering is done in <code class="verbatim">remaining</code>, where we check the
last button of every known sequence, and see if that matches the current
button. That’s what the line <code class="verbatim">filter ((==button) . last . fst)</code> does;
the sister line <code class="verbatim">filter (not . null . fst) dbRem</code> is just there to
prevent calling <code class="verbatim">last</code> on an empty list.</p>
<p>After we’re done checking, we modify the entire sequence database <code class="verbatim">db</code>,
such that we only care about the first <span class="math inline">\(N - 1\)</span> buttons in the sequence.
This way, on the next iteration, we can rest assured that checking
against the “last” button in a sequence is not always the same button.
In subsequent runs of <code class="verbatim">step</code>, we have <code class="verbatim">dbRem</code>’s sequences slowly get
reduced down to nothing as we keep chopping off all sequences’ last
button. Keep in mind that we feed the filtered, matching entries of <code class="verbatim">db</code>
back into subsequent runs of <code class="verbatim">step</code>, so that effectively we’re only
working with matching sequences. Once we reach down to no buttons, we
label these named sequences as <code class="verbatim">entriesComplete</code>, and append it into
<code class="verbatim">foundSoFar</code>.</p>
<h2 id="analysis">Analysis</h2>
<p>Obviously, this code has many problems. First, it is virtually
unreadable. Readability is important, and the code feels very
counter-intuitive — it is marvelously complex when the problem
statement sounds so simple.</p>
<p>Second, the fact that we have to bring in and mutate <code class="verbatim">dbRem</code>, which is a
copy of the original given <code class="verbatim">ButtonSeqDB</code> type, seems wasteful. We’re
wasting a lot of CPU cycles here.</p>
<h1 id="ruby-solution-using-hashes">Ruby Solution Using Hashes</h1>
<p>So on the day after (that is, <em>today</em> as of the time of this writing), I
thought about the problem again and realized we can use hashes. It is a
very simple approach, with far less lines of code. I even wrote some
tests for it. Here is the implementation below.</p>
<div class="code-and-raw">
<div class="sourceCode" id="cb4" data-startFrom="1"><pre class="sourceCode numberSource numberLines ruby"><code class="sourceCode ruby"><span id="cb4-1"><a href="#cb4-1"></a><span class="cf">module</span> <span class="dt">GameButtonSeq</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="co"># button_seq = [&quot;down&quot;, &quot;forward&quot;, &quot;punch&quot;]</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="co"># name = &quot;hadoken&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="co"># button_seq_db = a hash of {sequence =&gt; name}, but a sequence can have</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="co"># multiple names if that sequence already exists.</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="cf">def</span> <span class="dt">GameButtonSeq</span><span class="at">.register</span>(button_seq, name, button_seq_db)</span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="co"># If the sequence already exists, simply add the new name to the old name,</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="co"># and store it as a list of names.</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="cf">if</span> button_seq_db<span class="at">.key?</span>(button_seq)</span>
<span id="cb4-10"><a href="#cb4-10"></a>      button_seq_db<span class="kw">[</span>button_seq<span class="kw">]</span> <span class="kw">=</span> <span class="kw">[</span>name<span class="kw">]</span> <span class="kw">+</span> button_seq_db<span class="kw">[</span>button_seq<span class="kw">]</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="cf">else</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>      button_seq_db<span class="kw">[</span>button_seq<span class="kw">]</span> <span class="kw">=</span> <span class="kw">[</span>name<span class="kw">]</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="cf">end</span></span>
<span id="cb4-14"><a href="#cb4-14"></a></span>
<span id="cb4-15"><a href="#cb4-15"></a>    button_seq_db</span>
<span id="cb4-16"><a href="#cb4-16"></a>  <span class="cf">end</span></span>
<span id="cb4-17"><a href="#cb4-17"></a></span>
<span id="cb4-18"><a href="#cb4-18"></a>  <span class="cf">def</span> <span class="dt">GameButtonSeq</span><span class="at">.on_buttons</span>(button_seq, button_seq_db)</span>
<span id="cb4-19"><a href="#cb4-19"></a>    found <span class="kw">=</span> <span class="kw">[]</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>    <span class="co"># We search the entire button_seq_db hash for the full length of N buttons</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>    <span class="co"># first, then N - 1 buttons, then N - 2 buttons, until the search input</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>    <span class="co"># becomes 0. Meanwhile, we collect any and all matches that come our way.</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>    <span class="co"># The point is to search based on the *last* input button, as this is the</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>    <span class="co"># &quot;current&quot; button that should &quot;finish&quot; whatever combination/move we were</span></span>
<span id="cb4-25"><a href="#cb4-25"></a>    <span class="co"># trying to do.</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>    <span class="cf">while</span> button_seq<span class="at">.size</span> <span class="kw">&gt;</span> <span class="dv">0</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>      <span class="cf">if</span> button_seq_db<span class="at">.key?</span>(button_seq)</span>
<span id="cb4-28"><a href="#cb4-28"></a>        found <span class="kw">&lt;&lt;</span> button_seq_db<span class="kw">[</span>button_seq<span class="kw">]</span></span>
<span id="cb4-29"><a href="#cb4-29"></a>      <span class="cf">end</span></span>
<span id="cb4-30"><a href="#cb4-30"></a>      <span class="co"># Discard oldest button press, and search again. Even if we have a match,</span></span>
<span id="cb4-31"><a href="#cb4-31"></a>      <span class="co"># it's important to search for other matches, too.</span></span>
<span id="cb4-32"><a href="#cb4-32"></a>      button_seq<span class="at">.shift</span></span>
<span id="cb4-33"><a href="#cb4-33"></a>    <span class="cf">end</span></span>
<span id="cb4-34"><a href="#cb4-34"></a></span>
<span id="cb4-35"><a href="#cb4-35"></a>    <span class="co"># Clean up, so that we get [&quot;foo&quot;, &quot;bar&quot;] instead of [[&quot;foo&quot;], [&quot;bar&quot;]].</span></span>
<span id="cb4-36"><a href="#cb4-36"></a>    found<span class="at">.flatten</span></span>
<span id="cb4-37"><a href="#cb4-37"></a>  <span class="cf">end</span></span>
<span id="cb4-38"><a href="#cb4-38"></a></span>
<span id="cb4-39"><a href="#cb4-39"></a>  <span class="cf">def</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(button_hist, button_name)</span>
<span id="cb4-40"><a href="#cb4-40"></a>    button_hist <span class="kw">+</span> <span class="kw">[</span>button_name<span class="kw">]</span></span>
<span id="cb4-41"><a href="#cb4-41"></a>  <span class="cf">end</span></span>
<span id="cb4-42"><a href="#cb4-42"></a><span class="cf">end</span></span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>hash_ver.rb</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/game-button-seq/hash_ver.rb"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/game-button-seq/hash_ver.rb" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>And here is the test suite for it. You can run it with
<code class="verbatim">ruby test_hash_ver.rb</code>.</p>
<div class="code-and-raw">
<div class="sourceCode" id="cb5" data-startFrom="1"><pre class="sourceCode numberSource numberLines ruby"><code class="sourceCode ruby"><span id="cb5-1"><a href="#cb5-1"></a><span class="fu">require</span> <span class="vs">'minitest/autorun'</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="fu">require_relative</span> <span class="vs">'./hash_ver.rb'</span></span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="cf">class</span> <span class="dt">TestPuz</span> <span class="kw">&lt;</span> <span class="dt">Minitest</span><span class="kw">::</span><span class="dt">Test</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span class="cf">def</span> setup</span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="ot">@db</span> <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.register</span>(<span class="kw">[</span><span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span><span class="kw">]</span>, <span class="st">&quot;hadoken&quot;</span>, <span class="kw">{}</span>)</span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="ot">@db</span> <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.register</span>(<span class="kw">[</span><span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span><span class="kw">]</span>, <span class="st">&quot;charger&quot;</span>, <span class="ot">@db</span>)</span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="ot">@db</span> <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.register</span>(<span class="kw">[</span><span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span><span class="kw">]</span>, <span class="st">&quot;uppercut&quot;</span>, <span class="ot">@db</span>)</span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="co"># Aside: We can easily limit the size of button_hist[] by forcefully always</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="co"># saving only the last N key presses, with N determined by the longest</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="co"># button sequence.</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="ot">@button_hist</span> <span class="kw">=</span> <span class="kw">[]</span></span>
<span id="cb5-15"><a href="#cb5-15"></a></span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="ot">@button_hist</span> <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)</span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="ot">@button_hist</span> <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)</span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="ot">@button_hist</span> <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(<span class="ot">@button_hist</span>, <span class="st">&quot;down&quot;</span>)</span>
<span id="cb5-19"><a href="#cb5-19"></a>    <span class="ot">@button_hist</span> <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(<span class="ot">@button_hist</span>, <span class="st">&quot;forward&quot;</span>)</span>
<span id="cb5-20"><a href="#cb5-20"></a>    <span class="ot">@button_hist</span> <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(<span class="ot">@button_hist</span>, <span class="st">&quot;punch&quot;</span>)</span>
<span id="cb5-21"><a href="#cb5-21"></a>  <span class="cf">end</span></span>
<span id="cb5-22"><a href="#cb5-22"></a></span>
<span id="cb5-23"><a href="#cb5-23"></a>  <span class="cf">def</span> test_button_seq_multiple_names_entered</span>
<span id="cb5-24"><a href="#cb5-24"></a>    db2 <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.register</span>(<span class="kw">[</span><span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span><span class="kw">]</span>, <span class="st">&quot;uppercut_2&quot;</span>, <span class="ot">@db</span>)</span>
<span id="cb5-25"><a href="#cb5-25"></a>    button_hist2 <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(<span class="ot">@button_hist</span>, <span class="st">&quot;up&quot;</span>)</span>
<span id="cb5-26"><a href="#cb5-26"></a>    button_hist2 <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(button_hist2, <span class="st">&quot;punch&quot;</span>)</span>
<span id="cb5-27"><a href="#cb5-27"></a>    assert_equal <span class="kw">[</span><span class="st">&quot;uppercut_2&quot;</span>, <span class="st">&quot;uppercut&quot;</span><span class="kw">]</span>,</span>
<span id="cb5-28"><a href="#cb5-28"></a>      <span class="dt">GameButtonSeq</span><span class="at">.on_buttons</span>(button_hist2, db2)</span>
<span id="cb5-29"><a href="#cb5-29"></a>  <span class="cf">end</span></span>
<span id="cb5-30"><a href="#cb5-30"></a></span>
<span id="cb5-31"><a href="#cb5-31"></a>  <span class="cf">def</span> test_button_seq_no_sequence_found</span>
<span id="cb5-32"><a href="#cb5-32"></a>    <span class="co"># Add an unrecognized button.</span></span>
<span id="cb5-33"><a href="#cb5-33"></a>    button_hist2 <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(<span class="ot">@button_hist</span>, <span class="st">&quot;back&quot;</span>)</span>
<span id="cb5-34"><a href="#cb5-34"></a>    assert_equal <span class="kw">[]</span>,</span>
<span id="cb5-35"><a href="#cb5-35"></a>      <span class="dt">GameButtonSeq</span><span class="at">.on_buttons</span>(button_hist2, <span class="ot">@db</span>)</span>
<span id="cb5-36"><a href="#cb5-36"></a>  <span class="cf">end</span></span>
<span id="cb5-37"><a href="#cb5-37"></a></span>
<span id="cb5-38"><a href="#cb5-38"></a>  <span class="cf">def</span> test_button_seq_one_sequence_found</span>
<span id="cb5-39"><a href="#cb5-39"></a>    button_hist2 <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(<span class="ot">@button_hist</span>, <span class="st">&quot;up&quot;</span>)</span>
<span id="cb5-40"><a href="#cb5-40"></a>    button_hist2 <span class="kw">=</span> <span class="dt">GameButtonSeq</span><span class="at">.add_hist</span>(button_hist2, <span class="st">&quot;punch&quot;</span>)</span>
<span id="cb5-41"><a href="#cb5-41"></a>    assert_equal <span class="kw">[</span><span class="st">&quot;uppercut&quot;</span><span class="kw">]</span>,</span>
<span id="cb5-42"><a href="#cb5-42"></a>      <span class="dt">GameButtonSeq</span><span class="at">.on_buttons</span>(button_hist2, <span class="ot">@db</span>)</span>
<span id="cb5-43"><a href="#cb5-43"></a>  <span class="cf">end</span></span>
<span id="cb5-44"><a href="#cb5-44"></a></span>
<span id="cb5-45"><a href="#cb5-45"></a>  <span class="cf">def</span> test_button_seq_multiple_sequences_found</span>
<span id="cb5-46"><a href="#cb5-46"></a>    assert_equal <span class="kw">[</span><span class="st">&quot;hadoken&quot;</span>, <span class="st">&quot;charger&quot;</span><span class="kw">]</span>,</span>
<span id="cb5-47"><a href="#cb5-47"></a>      <span class="dt">GameButtonSeq</span><span class="at">.on_buttons</span>(<span class="ot">@button_hist</span>, <span class="ot">@db</span>)</span>
<span id="cb5-48"><a href="#cb5-48"></a>  <span class="cf">end</span></span>
<span id="cb5-49"><a href="#cb5-49"></a><span class="cf">end</span></span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>test_hash_ver.rb</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/game-button-seq/test_hash_ver.rb"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/game-button-seq/test_hash_ver.rb" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<h2 id="analysis-1">Analysis</h2>
<p>The key insight was when I realized that you could indeed use a hash
even though we have the requirement that multiple, identical button
sequences can have different names. The trick is to simply store the
value as not a single name, but an array of possible names. This is
reflected in the <code class="verbatim">GameButtonSeq.register</code> method.</p>
<p>The heart of <code class="verbatim">on_buttons()</code> is a single <code class="verbatim">while</code> loop that checks the
given button history against the database; we reduce the button sequence
by 1 button on each iteration to check against shorter matches as well.
That’s what the <code class="verbatim">button_seq.shift</code> is for.</p>
<h1 id="haskell-solution-using-hashes">Haskell Solution Using Hashes</h1>
<p>Inspired by the Ruby solution, I rewrote a Haskell version — with
tests to boot! Here is the implementation.</p>
<div class="code-and-raw">
<div class="sourceCode" id="cb6" data-startFrom="1"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">module</span> <span class="dt">GameButtonSeq</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">-- The database stores a list of Name values, because multiple sequences can</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">-- have the same name, in which case we store just one instance of the sequence,</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">-- but a list of multiple Name values.</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="kw">type</span> <span class="dt">ButtonSeqDB</span> <span class="ot">=</span> <span class="dt">M.Map</span> <span class="dt">ButtonSeq</span> [<span class="dt">Name</span>]</span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">type</span> <span class="dt">ButtonSeq</span> <span class="ot">=</span> [<span class="dt">String</span>]</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">-- If a button sequence is already given some set of names, add the current</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co">-- given name into that list of names..</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="ot">register ::</span> (<span class="dt">ButtonSeq</span>, <span class="dt">Name</span>) <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>register (buttonSeq, name) db <span class="ot">=</span> <span class="kw">case</span> M.lookup buttonSeq db <span class="kw">of</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>  <span class="dt">Just</span> names <span class="ot">-&gt;</span> M.insert buttonSeq (name<span class="op">:</span>names) db</span>
<span id="cb6-18"><a href="#cb6-18"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> M.insert buttonSeq [name] db</span>
<span id="cb6-19"><a href="#cb6-19"></a></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="co">-- Input `buttonSeq` is a list of buttons pressed, from oldest to newest, so</span></span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="co">-- that the head of the list contains the oldest button.</span></span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="ot">onButtons ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]</span>
<span id="cb6-23"><a href="#cb6-23"></a>onButtons buttonHist db <span class="ot">=</span> <span class="fu">concatMap</span> extractNames buttonHists</span>
<span id="cb6-24"><a href="#cb6-24"></a>  <span class="kw">where</span></span>
<span id="cb6-25"><a href="#cb6-25"></a>  buttonHists <span class="ot">=</span> <span class="fu">take</span> (<span class="fu">length</span> buttonHist) <span class="op">$</span> <span class="fu">iterate</span> <span class="fu">tail</span> buttonHist</span>
<span id="cb6-26"><a href="#cb6-26"></a>  extractNames bHist <span class="ot">=</span> <span class="kw">case</span> M.lookup bHist db <span class="kw">of</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>    <span class="dt">Just</span> names <span class="ot">-&gt;</span> names</span>
<span id="cb6-28"><a href="#cb6-28"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</span>
<span id="cb6-29"><a href="#cb6-29"></a></span>
<span id="cb6-30"><a href="#cb6-30"></a><span class="ot">onButtons2 ::</span> <span class="dt">ButtonSeq</span> <span class="ot">-&gt;</span> <span class="dt">ButtonSeqDB</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]</span>
<span id="cb6-31"><a href="#cb6-31"></a>onButtons2 buttonHist db <span class="ot">=</span> <span class="fu">concat</span> <span class="op">$</span> mapMaybe (<span class="fu">flip</span> M.lookup db) buttonHists</span>
<span id="cb6-32"><a href="#cb6-32"></a>  <span class="kw">where</span></span>
<span id="cb6-33"><a href="#cb6-33"></a>  buttonHists <span class="ot">=</span> <span class="fu">take</span> (<span class="fu">length</span> buttonHist) <span class="op">$</span> <span class="fu">iterate</span> <span class="fu">tail</span> buttonHist</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>GameButtonSeq.hs</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/game-button-seq/GameButtonSeq.hs"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/game-button-seq/GameButtonSeq.hs" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>The file is named <code class="verbatim">GameButtonSeq</code> because of Haskell naming conventions
for files containing module code. And here is the test for it.</p>
<div class="code-and-raw">
<div class="sourceCode" id="cb7" data-startFrom="1"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">import</span> <span class="dt">Test.Tasty</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">import</span> <span class="dt">Test.Tasty.HUnit</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">import</span> <span class="dt">GameButtonSeq</span></span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-11"><a href="#cb7-11"></a>main <span class="ot">=</span> defaultMain tests</span>
<span id="cb7-12"><a href="#cb7-12"></a></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="ot">tests ::</span> <span class="dt">TestTree</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>tests <span class="ot">=</span> testGroup <span class="st">&quot;Tests&quot;</span> [qcProps, unitTests]</span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="ot">qcProps ::</span> <span class="dt">TestTree</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>qcProps <span class="ot">=</span> testGroup <span class="st">&quot;(checked by QuickCheck)&quot;</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>  [ QC.testProperty <span class="st">&quot;GameButtonSeq (empty DB cannot produce matches)&quot;</span> <span class="op">$</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>    \buttonHist <span class="ot">-&gt;</span> onButtons (<span class="ot">buttonHist ::</span> <span class="dt">ButtonSeq</span>) M.empty <span class="op">==</span> []</span>
<span id="cb7-20"><a href="#cb7-20"></a>  ]</span>
<span id="cb7-21"><a href="#cb7-21"></a></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="ot">unitTests ::</span> <span class="dt">TestTree</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>unitTests <span class="ot">=</span> testGroup <span class="st">&quot;Unit tests&quot;</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>  [ testCase <span class="st">&quot;GameButtonSeq (entry of multiple sequences with same name)&quot;</span> <span class="op">$</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>    (onButtons [<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>]</span>
<span id="cb7-26"><a href="#cb7-26"></a>    <span class="op">$</span> register ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], <span class="st">&quot;uppercut_2&quot;</span>) buttonSeqDB)</span>
<span id="cb7-27"><a href="#cb7-27"></a>      <span class="op">@?=</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>      [<span class="st">&quot;uppercut_2&quot;</span>, <span class="st">&quot;uppercut&quot;</span>]</span>
<span id="cb7-29"><a href="#cb7-29"></a>  , testCase <span class="st">&quot;GameButtonSeq (no sequence found)&quot;</span> <span class="op">$</span></span>
<span id="cb7-30"><a href="#cb7-30"></a>    onButtons</span>
<span id="cb7-31"><a href="#cb7-31"></a>      [<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>, <span class="st">&quot;down&quot;</span>]</span>
<span id="cb7-32"><a href="#cb7-32"></a>      buttonSeqDB</span>
<span id="cb7-33"><a href="#cb7-33"></a>      <span class="op">@?=</span></span>
<span id="cb7-34"><a href="#cb7-34"></a>      []</span>
<span id="cb7-35"><a href="#cb7-35"></a>  , testCase <span class="st">&quot;GameButtonSeq (one sequences found)&quot;</span> <span class="op">$</span></span>
<span id="cb7-36"><a href="#cb7-36"></a>    onButtons</span>
<span id="cb7-37"><a href="#cb7-37"></a>      [<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>]</span>
<span id="cb7-38"><a href="#cb7-38"></a>      buttonSeqDB</span>
<span id="cb7-39"><a href="#cb7-39"></a>      <span class="op">@?=</span></span>
<span id="cb7-40"><a href="#cb7-40"></a>      [<span class="st">&quot;uppercut&quot;</span>]</span>
<span id="cb7-41"><a href="#cb7-41"></a>  , testCase <span class="st">&quot;GameButtonSeq (multiple sequences found)&quot;</span> <span class="op">$</span></span>
<span id="cb7-42"><a href="#cb7-42"></a>    onButtons</span>
<span id="cb7-43"><a href="#cb7-43"></a>      [<span class="st">&quot;down&quot;</span>, <span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>]</span>
<span id="cb7-44"><a href="#cb7-44"></a>      buttonSeqDB</span>
<span id="cb7-45"><a href="#cb7-45"></a>      <span class="op">@?=</span></span>
<span id="cb7-46"><a href="#cb7-46"></a>      [<span class="st">&quot;hadoken&quot;</span>, <span class="st">&quot;charger&quot;</span>]</span>
<span id="cb7-47"><a href="#cb7-47"></a>  ]</span>
<span id="cb7-48"><a href="#cb7-48"></a>  <span class="kw">where</span></span>
<span id="cb7-49"><a href="#cb7-49"></a>  <span class="co">-- Default DB of button sequences.</span></span>
<span id="cb7-50"><a href="#cb7-50"></a><span class="ot">  buttonSeqDB ::</span> <span class="dt">M.Map</span> <span class="dt">ButtonSeq</span> [<span class="dt">Name</span>]</span>
<span id="cb7-51"><a href="#cb7-51"></a>  buttonSeqDB <span class="ot">=</span> M.fromList</span>
<span id="cb7-52"><a href="#cb7-52"></a>    [ ([<span class="st">&quot;down&quot;</span>, <span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;hadoken&quot;</span>])</span>
<span id="cb7-53"><a href="#cb7-53"></a>    , ([<span class="st">&quot;forward&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;charger&quot;</span>])</span>
<span id="cb7-54"><a href="#cb7-54"></a>    , ([<span class="st">&quot;up&quot;</span>, <span class="st">&quot;punch&quot;</span>], [<span class="st">&quot;uppercut&quot;</span>])</span>
<span id="cb7-55"><a href="#cb7-55"></a>    ]</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>test_hash_ver.hs</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/game-button-seq/test_hash_ver.hs"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/game-button-seq/test_hash_ver.hs" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<h2 id="analysis-2">Analysis</h2>
<p>This Haskell version uses the standard <code class="verbatim">Data.Map</code> module, which provides
an efficient, basic hash data structure. What we first do is expand
<code class="verbatim">buttonHist</code> to all of the cases we are interested in — namely, all of
the subsequences of concern. E.g., given a list like
<code class="verbatim">["up", "down", "right", "left"]</code>, <code class="verbatim">buttonHists</code> becomes:</p>
<pre class="example"><code>[ [&quot;up&quot;, &quot;down&quot;, &quot;right&quot;, &quot;left&quot;]
,       [&quot;down&quot;, &quot;right&quot;, &quot;left&quot;]
,               [&quot;right&quot;, &quot;left&quot;]
,                        [&quot;left&quot;]
]
</code></pre>
<p>(spaces added for readability). What we do is reduce the initial input
list into all of the “sublist” combinations of <span class="math inline">\(N\)</span> buttons, <span class="math inline">\(N - 1\)</span>
buttons, <span class="math inline">\(N - 2\)</span> buttons, etc.</p>
<p>The next step is to simply look at each sublist with <code class="verbatim">concatMap</code>,
calling <code class="verbatim">extractNames</code>; we treat each sublist as a key, and look for it
in our <code class="verbatim">db</code> hash. We then simply concatenate the results.</p>
<p>The <code class="verbatim">onButtons2</code> is an alternate version which uses <code class="verbatim">mapMaybe</code> to reduce
it down to just two lines of code.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I cringe as I look back at the half-baked code I wrote during the
interview. Even the working, compilable version that I wrote after the
interview remains ugly and hard to reason about. I can picture my
interviewer being grossed out by my ugly, hacky version wondering if I
even know what hashes are…</p>
<p>The moral of the story is to think carefully about the most obvious data
structure to use, before embarking on writing a solution — no matter
how trivial it seems. For myself, I was nervous and did not realize how
simple the problem actually was until the day after when I rewrote the
solution in Ruby. It was so simple and straightforward that I even wrote
some test cases for it<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>I hope you had some fun writing out your own solutions. Happy hacking!</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>You can test the Haskell hash version in this blog post if you
clone this blog’s repo and then build it with Cabal (I’ve listed
the program as an executable with all the constraints in the
<code class="verbatim">blog.cabal</code> file in the repo root folder). For the Ruby version,
simply do <code class="verbatim">ruby path/to/test_hash_ver.rb</code> and Ruby will run the
tests inside.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

		</div>

		<div id="footer">
			<img src="../favicon.png" id="brand-icon">
			<p>Copyright (C) 2013-2024 Linus Arver. All rights reserved.</p>
			<a href="https://github.com/listx/listx_blog">Site</a>
			<a href="https://github.com/listx/listx.github.io">generated</a>
			with
			<a href="https://jaspervdj.be/hakyll">Hakyll</a>
			and
			<a href="http://sebastiaanvisser.github.com/clay">Clay</a>.
			<br>
			<a href="../atom.xml">Atom feed</a>
		</div>
	</body>
</html>
