<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Linus’s Blog - SRM 485: AfraidOfEven</title>
		<link rel="stylesheet" href="../css/base.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Serif+Pro">
		<link rel="shortcut icon" type="image/png" href="../favicon.png">
		<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
		<script src="../misc.js"></script>
		<!-- https://github.com/mreid/markreidname-hakyll/blob/master/_templates/mathjax.html -->
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		extensions: ["tex2jax.js"],
		jax: ["input/TeX", "output/HTML-CSS"],
		tex2jax: {
			inlineMath: [ ["\\(","\\)"] ],
			displayMath: [ ["\\[","\\]"] ],
			processEscapes: true
		},
		TeX: { equationNumbers: { autoNumber: "AMS" } },
		"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>

	</head>
	<body>
		<div id="header">
			<a href="../">funloop.org</a>
			|
			<a href="../about.html">About</a>
			|
			<a href="../etc.html">Etc</a>
		</div>

		<div id="sticky-title">
			<h1 class="center" id="page-title">SRM 485: AfraidOfEven</h1>
		</div>

		<div id="content">
			<div class="info center">
	<a class="history" href="https://github.com/listx/listx_blog/commits/master/post/2015-05-04-puzzle-srm-485-afraid-of-even.org" title="History"><code class="date">2015-05-04</code></a>
	<br>
	<a title="All pages tagged 'programming'." href="../tag/programming.html">programming</a>, <a title="All pages tagged 'math'." href="../tag/math.html">math</a>, <a title="All pages tagged 'haskell'." href="../tag/haskell.html">haskell</a>, <a title="All pages tagged 'ruby'." href="../tag/ruby.html">ruby</a>
</div>

<h1 id="introduction">Introduction</h1>
<p>The heart of this problem comes from TopCoder’s <a href="http://community.topcoder.com/stat?c%3Dproblem_statement&amp;pm%3D11146&amp;rd%3D14238">SRM 485 “AfraidOfEven”</a>.
There is quite a lot of discussion behind the somewhat elementary math principles, so you might want to skip down to the code directly after reading the problem statement.</p>
<h1 id="the-problem">The Problem</h1>
<p>An <a href="http://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic progression</a> <span class="math inline">\(AP\)</span> has been changed by the mutation function <span class="math inline">\(M()\)</span> in the following way: any even number <span class="math inline">\(w\)</span> in the sequence has been replaced by <span class="math inline">\(\frac{w}{2}\)</span>, repeatedly, until it has become odd.
For example, if <span class="math inline">\(AP = \{2, 4, 6, 8\}\)</span>, then <span class="math inline">\(M(AP) = \{1, 1, 3, 1\}\)</span> (because <span class="math inline">\(\frac{6}{2} = 3\)</span> and <span class="math inline">\(3\)</span> is an odd number, it stopped mutating).
Given a mutated sequence <span class="math inline">\(M(AP) = MP\)</span>, design an “unmutate” function <span class="math inline">\(U()\)</span> such that <span class="math inline">\(U(MP) \approx AP\)</span>.
If more than one possible sequence <span class="math inline">\(AP\)</span> exists, find the one with the lowest lexicographical order.</p>
<h2 id="constraints">Constraints</h2>
<p><span class="math inline">\(MP\)</span> is limited to 4 to 50 terms.
Each term in <span class="math inline">\(MP\)</span> is from <span class="math inline">\(1\)</span> to <span class="math inline">\(1000\)</span>, inclusive (for now; later on we will consider numbers less than <span class="math inline">\(1\)</span>).
The difference (let’s call it <span class="math inline">\(m\)</span>) between each term can be <span class="math inline">\(0\)</span>, so the following is still a valid arithmetic progression: <span class="math inline">\(\{-17, -17, -17, -17, -17\}\)</span>.</p>
<h3 id="lexicographic-order">Lexicographic Order</h3>
<p>Given the input</p>
<p><span class="math display">\[
MP = \{1, 1, 3, 1, 5\}
\]</span></p>
<p>, we get the output</p>
<p><span class="math display">\[
U(AP) = \{1, 2, 3, 4, 5\}
\]</span></p>
<p>. It is possible that <span class="math inline">\(AP\)</span> was actually <span class="math inline">\(\{2, 4, 6, 8, 10\}\)</span> (or even <span class="math inline">\(\{4, 8, 12, 16, 20\}\)</span>), but because <span class="math inline">\(\{1, 2, 3, 4, 5\}\)</span> has the smaller lexicographic representation, it is the correct answer.</p>
<h1 id="interlude">Interlude</h1>
<p>I will include both Haskell and Ruby solutions in this post below.
If you’d like to solve the problem on your own, please read the rest of this post at a later time.</p>
<h1 id="the-math">The Math</h1>
<p>Let us consider the universe of possible arithmetic progressions, and then derive a general algorithm.
Because the mutation involves even numbers, it makes sense to look at arithmetic progressions in terms of even and odd numbers (aka <em>parity</em>).</p>
<p>The two most important parts of an arithmetic progression are the rate of change, <span class="math inline">\(m\)</span>, and the first term <span class="math inline">\(A_0\)</span>.
This is because any arithmetic progression can be recreated by knowing only these two values.</p>
<p>Now, <span class="math inline">\(m\)</span> can be either even (<span class="math inline">\(E\)</span>), odd (<span class="math inline">\(O\)</span>), or zero.
The first term <span class="math inline">\(A_0\)</span> can be either even or odd.
Let’s plug these possible variations into a table, and see if there are any patterns we can exploit.
To determine <span class="math inline">\(AP\)</span> based on <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, we only need to know three laws of parity:</p>
<ol type="1">
<li><span class="math inline">\(\mathrm{O + O = E}\)</span></li>
<li><span class="math inline">\(\mathrm{E + E = E}\)</span></li>
<li><span class="math inline">\(\mathrm{O + E = O}\)</span></li>
</ol>
<p>.
Using these laws, we can construct the entire sequence <span class="math inline">\(AP\)</span> by adding <span class="math inline">\(m\)</span> into <span class="math inline">\(A_0\)</span> repeatedly.</p>
<p>The only time that adding two numbers together results in an odd number is when one term is odd and the other term is even.
This rule is true regardless of whether we are adding or subtracting (adding a negative term), or whether either term is positive or negative.
Another interesting point is that adding by an even number does not change the parity of the original term, while adding by an odd number always flips the parity of the original.
We now know how to construct <span class="math inline">\(AP\)</span> from <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, so let’s examine the possible outcomes below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(m\)</span></th>
<th style="text-align: center;"><span class="math inline">\(A_0\)</span></th>
<th style="text-align: center;"><span class="math inline">\(AP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.
Let’s now look at each of the 6 possible cases, and see if we can simplify things more.
We will look at each case from the perspective of <span class="math inline">\(m\)</span>.</p>
<h2 id="mutation-when-m-is-zero">Mutation When <span class="math inline">\(m\)</span> is Zero</h2>
<p>If <span class="math inline">\(m\)</span> is zero, then <span class="math display">\[AP = {A_0, A_0, A_0\cdots{}A_0}\]</span>.
That is, subsequent terms after <span class="math inline">\(A_0\)</span> do not change, so it is a constant sequence of the first term, <span class="math inline">\(A_0\)</span>.</p>
<p>If <span class="math inline">\(m\)</span> is zero and <span class="math inline">\(A_0\)</span> is <strong>odd</strong>, then all terms remain the same after the mutation; so, <span class="math inline">\(M(AP) = AP\)</span> (no change).
E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(AP = \{\mathrm{3, 3, 3, 3, \cdots{}, 3}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(MP = \{\mathrm{3, 3, 3, 3, \cdots{}, 3}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.
If <span class="math inline">\(m\)</span> is zero and <span class="math inline">\(A_0\)</span> is <strong>even</strong>, then all terms are likewise even, and all terms will become odd by application of <span class="math inline">\(M()\)</span>.
What’s more, every term in <span class="math inline">\(M_0\)</span> will be the same odd number, essentially becoming “reduced” to the case where <span class="math inline">\(A_0\)</span> was originally odd.
E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(AP = \{\mathrm{10, 10, 10, 10, \cdots{}, 10}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(MP = \{\mathrm{5, 5, 5, 5, \cdots{}, 5}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h2 id="mutation-when-m-is-even">Mutation When <span class="math inline">\(m\)</span> is Even</h2>
<p>If <span class="math inline">\(m\)</span> is even, then all terms in <span class="math inline">\(AP\)</span> are either even or odd, based on the first term <span class="math inline">\(A_0\)</span>.
Essentially, <span class="math inline">\(AP\)</span> behaves in an identical manner to the case where <span class="math inline">\(m = 0\)</span> as far as parity is concerned — the only difference here is that the subsequent terms change in value by <span class="math inline">\(m\)</span>.</p>
<p>However, there is a slight twist when we apply mutation.
If <span class="math inline">\(A_0 = \mathrm{O}\)</span>, then there are no numbers to mutate, and we get <span class="math inline">\(MP\)</span> where all terms are odd and they change by <span class="math inline">\(m\)</span>.
But if <span class="math inline">\(A_0 = \mathrm{E}\)</span>, then we get <em>changing</em> even numbers for <span class="math inline">\(MP\)</span>.
So unlike in the case of <span class="math inline">\(m = 0\)</span> where all even numbers reduced down to the same odd number after applying the mutation, we get <em>different</em> odd numbers.
E.g.,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(AP = \{\mathrm{40, 48, 56, 64, 72}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(MP = \{\mathrm{5, 3, 7, 1, 9}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.
Notice how even though <span class="math inline">\(AP\)</span> has a sequence of <em>increasing</em> terms, <span class="math inline">\(MP\)</span>’s terms are not increasing in the same manner.
We will revisit this case below when simplifying the categories of behavior for <span class="math inline">\(MP\)</span>.</p>
<h2 id="mutation-when-m-is-odd">Mutation When <span class="math inline">\(m\)</span> is Odd</h2>
<p>This is where things get interesting.
If <span class="math inline">\(m\)</span> is odd, then <span class="math inline">\(AP\)</span> becomes a <em>series of alternating even and odd numbers</em>.
Whether <span class="math inline">\(AP\)</span> begins with an even or odd number depends, naturally, on the parity of <span class="math inline">\(A_0\)</span>.
The more general observation we can make is that, given the fact that we have alternating even and odd numbers in <span class="math inline">\(AP\)</span>, <span class="math inline">\(MP\)</span> will be populated with “originally odd” and “fake odd” (mutated) terms.
Let’s call these mutated terms <span class="math inline">\(O_F\)</span>.
So if <span class="math inline">\(m\)</span> is odd, then we get either</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(AP = \{\mathrm{O, E, O, E}\}, MP = \{\mathrm{O, O_F, O, O_F}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">or</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(AP = \{\mathrm{E, O, E, O}\}, MP = \{\mathrm{O_F, O, O_F, O}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h1 id="a-summary-of-the-behavior-of-the-mutation-function-m">A Summary of the Behavior of the Mutation Function <span class="math inline">\(M()\)</span></h1>
<p>We’ve exhausted the universe of all possible arithmetic sequences, and how they would mutate after applying <span class="math inline">\(M()\)</span>.
We know exactly how <span class="math inline">\(M()\)</span> behaves in all edge cases!
Let us now simplify the various cases to two general cases.</p>
<h2 id="there-is-nothing-to-unmutate-as-mp-is-already-the-same-as-the-answer-ap">There is nothing to “unmutate” as <span class="math inline">\(MP\)</span> is already the same as the answer <span class="math inline">\(AP\)</span></h2>
<p>This can happen in two ways.
The easiest way is if <span class="math inline">\(m = 0\)</span>, where all terms in <span class="math inline">\(MP\)</span> are the same and there is nothing to calculate (<span class="math inline">\(M()\)</span> will ensure that this case always results in the same repeating odd number).
The other way is if <span class="math inline">\(m\)</span> is even, and <span class="math inline">\(A_0\)</span> is odd — resulting in an “unmutatable” sequence such that <span class="math inline">\(M(AP) = AP\)</span>.
E.g. (where <span class="math inline">\(m = 10\)</span> and <span class="math inline">\(A_0 = 11\)</span>),</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(AP = \{\mathrm{11, 21, 31, 41, 51}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(MP = \{\mathrm{11, 21, 31, 41, 51}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.</p>
<h2 id="the-terms-in-ap-alternate-between-even-and-odd">The terms in <span class="math inline">\(AP\)</span> alternate between even and odd</h2>
<p>This covers the case when <span class="math inline">\(m\)</span> is odd.
If <span class="math inline">\(m\)</span> is odd, then regardless of the parity of <span class="math inline">\(A_0\)</span>, we get an alternating sequence of even and odd numbers.
The import thing to keep in mind here is that the even numbers will mutate after <span class="math inline">\(\mathrm{M()}\)</span> is applied, while the odd numbers will stay as-is as “originals”.</p>
<h1 id="how-to-design-u">How to Design <span class="math inline">\(U()\)</span></h1>
<p>Let’s think back to what our mutation function <span class="math inline">\(M()\)</span> does: it simply mutates an even number to an odd number by repeatedly dividing it by 2.
If the number if odd to begin with, then there is nothing to mutate; essentially, <em>original</em> odd numbers act as immutable beacons of truth — they do not have to change form when returning to their <span class="math inline">\(AP\)</span> form!
Our task in designing an “unmutate” function <span class="math inline">\(U()\)</span> is to preserve the “honest” odd numbers while converting the mutated, “fake” odd numbers back to their evenness, to get back the original progression <span class="math inline">\(AP\)</span> (or at least something close to it if there are multiple such <span class="math inline">\(AP\)</span>s out there.</p>
<p>You can now see where our extensive parity breakdown of the possible <span class="math inline">\(MP\)</span> can come in handy — we know in what patterns the honest odd numbers show themselves in <em>any</em> <span class="math inline">\(MP\)</span>.
Let’s rewrite the table of all possibilities, with this analogy of “honest” and “fake” (<span class="math inline">\(O_F\)</span>) odd numbers after the mutation.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(m\)</span></th>
<th style="text-align: center;"><span class="math inline">\(A_0\)</span></th>
<th style="text-align: center;"><span class="math inline">\(AP\)</span></th>
<th style="text-align: center;"><span class="math inline">\(MP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{E, E, E, E, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(?\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>As you can see, the two dominating patterns are either the all-odd (and honest!) numbers (first 3 rows) or the alternating honest or fake odd numbers.
But what about the case where <span class="math inline">\(m\)</span> is a nonzero even value and <span class="math inline">\(A_0\)</span> is even as well (row 4)?
In the universe of all possible even numbers of <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>, how can we know for a fact that the mutation to <span class="math inline">\(MP\)</span> will fall into a neat pattern?</p>
<h1 id="when-both-m-and-a_0-are-even">When both <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span> are even</h1>
<p>The short answer is, we can prove that all such sequences will mutate to the familiar <span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span>, <span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span>, or <span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span> pattern shown in the table above.
The long answer is that it helps to think of linear equations, and to see the possible ways in which we can <em>grow</em> the <span class="math inline">\(AP\)</span> progression from <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span>.</p>
<p>If you paid attention in high school algebra class, you will probably remember the formula <span class="math inline">\(y = mx + b\)</span> to describe a straight line (except the vertical line!) in the cartesian coordinate system (in the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> axes).
We can use the <strong>same</strong> equation to describe the growth behavior of an arithmetic sequence!
And for that, we use the following translation:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(y = mx + b\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_n = mn + A_0\)</span></td>
</tr>
</tbody>
</table>
<p>, where <span class="math inline">\(A_n\)</span> is the n-th term to be calculated in <span class="math inline">\(AP\)</span>.
Luckily, we’ve used the same letter <span class="math inline">\(m\)</span> in both contexts — it describes the rate of change in one, and the distance between each term in the other.
Let’s simplify the equation with a concern to parity only.</p>
<p>First, let’s rewrite the equation as follows:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_n = \mathrm{E\cdot{}}n + \mathrm{E}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">or</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_n = \mathrm{E_m}\cdot{}n + \mathrm{E_{A0}}\)</span></td>
</tr>
</tbody>
</table>
<p>.
The <span class="math inline">\(\mathrm{E}\)</span> here represents that this number is an even number, with the subscript denoting whether it is <span class="math inline">\(m\)</span> (<span class="math inline">\(\mathrm{E_m}\)</span>) or the first term in the sequence (<span class="math inline">\(\mathrm{E_{A0}}\)</span>).
If we use this equation to map out the first 4 elements of <span class="math inline">\(AP\)</span>, we get the following:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_0 = \mathrm{E_m\cdot{}0 + E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(A_1 = \mathrm{E_m\cdot{}1 + E_{A0}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_2 = \mathrm{E_m\cdot{}2 + E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(A_3 = \mathrm{E_m\cdot{}3 + E_{A0}}\)</span></td>
</tr>
</tbody>
</table>
<p>.
It should be noted that both <span class="math inline">\(\mathrm{E_m}\)</span> and <span class="math inline">\(\mathrm{E_{A0}}\)</span> remain the <strong>same</strong> throughout the entire sequence <span class="math inline">\(AP\)</span>.
The only thing that changes is <span class="math inline">\(n\)</span>, which always increments by <span class="math inline">\(1\)</span>, starting from <span class="math inline">\(0\)</span>.</p>
<p>And now we’re faced with a problem.
Ideally, we’d like to get rid of all those even terms in our formula — they don’t help us out at all!
This is where we use the concept of <em>scaling</em>.
There are two scaling rules: (1) if you multiply all terms of an arithmetic progression by some nonzero integer <span class="math inline">\(k\)</span>, <em>the new progression remains arithmetic</em>; (2) the same is true if you divide all terms by <span class="math inline">\(k\)</span>.</p>
<p>The first scaling rule works because</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_n = \mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_n\cdot{}k = (\mathrm{E_m\cdot{}}n + \mathrm{E_{A0}})\cdot{}k\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_n\cdot{}k = (\mathrm{E_m}\cdot{}{k})\cdot{}n + \mathrm{E_{A0}}\cdot{}k\)</span></td>
</tr>
</tbody>
</table>
<p>, where the terms <span class="math inline">\(\mathrm{E_{A0}}\cdot{}k\)</span> and <span class="math inline">\(\mathrm{E_m}\cdot{}k\)</span> both remain as constants — we are still dealing with a <a href="http://en.wikipedia.org/wiki/Degree_of_a_polynomial">degree 1 polynomial</a> (linear expression).
Apart from increasing the first term <span class="math inline">\(\mathrm{A_0}\)</span> by <span class="math inline">\(k\)</span>, all we did was increase the gap between each term by a factor of <span class="math inline">\(k\)</span>.
Likewise, if you <em>divide</em> all terms of an arithmetic progression by some nonzero integer <span class="math inline">\(k\)</span>, the new progression still remains arithmetic, because what you are doing is</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(A_n = \mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\frac{A_n}{k} = \frac{\mathrm{E_m\cdot{}}n + \mathrm{E_{A0}}}{k}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">becomes</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\frac{A_n}{k} = \frac{\mathrm{E_m}}{k}\cdot{}n + \frac{\mathrm{E_{A0}}}{k}\)</span></td>
</tr>
</tbody>
</table>
<p>.
Division is simply multiplication by the inverse, so the same reasoning as for the first scaling rule applies here as well.
By the way, we don’t have to worry about what <span class="math inline">\(A_n\cdot{}k\)</span> or <span class="math inline">\(\frac{A_n}{k}\)</span> would look like — we are merely concerned with how <em>parity</em> behaves, and for that we rely on the right hand side of the equation.</p>
<p>Going back to our problem, recall that we want to ultimately output some arithmetic progression that <em>could</em> have resulted in the given mutated list <span class="math inline">\(MP\)</span>.
This is what scaling gives us — it gives us the leeway that we need to stay within our original problem domain while changing around the parity of <span class="math inline">\(A_n\)</span> with <span class="math inline">\(k\)</span>.</p>
<p>Let us scale the entire progression by <span class="math inline">\(k = \frac{1}{2}\)</span>.
That is, let us repeatedly divide <span class="math inline">\(\mathrm{E_m}\)</span> and <span class="math inline">\(\mathrm{E_{A0}}\)</span> by 2, until one or both of them become odd.
When either one becomes odd, we stop scaling and reuse the parity laws we discussed above to draw deeper conclusions.
Which variable, <span class="math inline">\(\mathrm{E_m}\)</span> or <span class="math inline">\(\mathrm{E_{A0}}\)</span>, has more 2’s in it (as prime factors)?
Which term is more <em>even</em> than the other?</p>
<p>There are three possible scenarios when we scale (let’s call it <span class="math inline">\(\mathrm{S()}\)</span>) by <span class="math inline">\(\frac{1}{2}\)</span> <strong>repeatedly</strong> as described above: (1) <span class="math inline">\(\mathrm{E_{A0}}\)</span> becomes odd first, (2) <span class="math inline">\(\mathrm{E_m}\)</span> becomes odd first, or (3) both become equally odd.
If we write these three scenarios into a table, we get the following:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Scaled by <span class="math inline">\(\frac{1}{2}\)</span> repeatedly</th>
<th style="text-align: center;">Parity of Scaled <span class="math inline">\(AP\)</span></th>
<th style="text-align: center;">Parity of Scaled <span class="math inline">\(MP\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{E\cdot{}}n + \mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O, O, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{O\cdot{}}n + \mathrm{E}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{E, O, E, O, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(\mathrm{S(E_m\cdot{}}n + \mathrm{E_{A0}}) = \mathrm{O\cdot{}}n + \mathrm{O}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, E, O, E, \cdots{}}\}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span></td>
</tr>
</tbody>
</table>
<p>.
The parity of each scaled <span class="math inline">\(AP\)</span> is calculated by simply replacing <span class="math inline">\(n\)</span> with 0, 1, 2, etc. and relying on our three parity laws from the beginning of this post.
If you want to lessen your load of mental arithmetic, we can simplify the parity expressions further.
If we reword the additive parity laws with multiplication in mind (which is simply addition repeated many times over), we can derive two more parity laws:</p>
<ol type="1">
<li><span class="math inline">\(\mathrm{E\cdot{}}n = \mathrm{E}\)</span>, regardless of <span class="math inline">\(n\)</span>, and</li>
<li><span class="math inline">\(\mathrm{O\cdot{}}n = \mathrm{P}_n\)</span> — i.e., the parity of <span class="math inline">\(\mathrm{O\cdot{}}n\)</span> is the same as the parity of <span class="math inline">\(n\)</span> itself</li>
</ol>
<p>.
Going back to our table above, we can simplify the scaled expressions further:</p>
<ol type="1">
<li><span class="math inline">\(\mathrm{E + O} = \mathrm{O}\)</span>, because adding by an even number preserves the parity of <span class="math inline">\(\mathrm{O}\)</span>.</li>
<li><span class="math inline">\(\mathrm{P}_n + \mathrm{E} = \mathrm{P}_n\)</span>, because adding by an even number preserves the parity of <span class="math inline">\(\mathrm{P}_n\)</span>.</li>
<li><span class="math inline">\(\mathrm{P}_n + \mathrm{O} = \neg{}\mathrm{P}_n\)</span>, because adding by an odd number flips the parity of <span class="math inline">\(\mathrm{P}_n\)</span></li>
</ol>
<p>.</p>
<p>And now we can finally say that when both <span class="math inline">\(m\)</span> and <span class="math inline">\(A_0\)</span> are even, the parity of terms in in <span class="math inline">\(AP\)</span> can be either all odd or alternating between even and odd!
I.e., if both <span class="math inline">\(m = \mathrm{E}\)</span> and <span class="math inline">\(A_0 = \mathrm{E}\)</span>, then <span class="math inline">\(M(AP) = \{\mathrm{O, O, O, O, \cdots{}}\}\)</span>, <span class="math inline">\(\{\mathrm{O, O_F, O, O_F, \cdots{}}\}\)</span>, or <span class="math inline">\(\{\mathrm{O_F, O, O_F, O, \cdots{}}\}\)</span>!</p>
<h1 id="back-to-designing-u">Back to Designing <span class="math inline">\(U()\)</span></h1>
<p>Through our discussion up to this point, we’ve established that the universe of all possible <span class="math inline">\(MP\)</span>’s fall under three parity patterns: all honest odd (<span class="math inline">\(\mathrm{O}\)</span>) terms, or alternating between “honest” odd (<span class="math inline">\(\mathrm{O}\)</span>) and “fake” odd (<span class="math inline">\(\mathrm{O_F}\)</span>) terms.
There are actually four patterns because the all-honest-odd-terms pattern can be broken down into two cases: (1) all terms are the same odd number (<span class="math inline">\(m = 0\)</span>), or (2) the terms are the same as those in <span class="math inline">\(AP\)</span> (i.e., <span class="math inline">\(AP\)</span> was all odd terms to begin with, so there was no actual mutation involved by applying <span class="math inline">\(M()\)</span>).</p>
<p>So, we can finally start sketching out the design for our “unmutate” function <span class="math inline">\(U()\)</span>.</p>
<div class="code-and-raw">
<div class="sourceCode" id="cb1" data-startFrom="1"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb1-1"><a href="#cb1-1"></a># Convert MP into a possible AP.</span>
<span id="cb1-2"><a href="#cb1-2"></a>def unmutate(MP)</span>
<span id="cb1-3"><a href="#cb1-3"></a>	if length(MP) &lt; 4</span>
<span id="cb1-4"><a href="#cb1-4"></a>		return NULL (we need at least 4 values to calculate an AP)</span>
<span id="cb1-5"><a href="#cb1-5"></a>	elsif every term in MP are the same</span>
<span id="cb1-6"><a href="#cb1-6"></a>		return MP (no change)</span>
<span id="cb1-7"><a href="#cb1-7"></a>	elsif MP is already an arithmetic sequence (MP = AP)</span>
<span id="cb1-8"><a href="#cb1-8"></a>		return MP (no change)</span>
<span id="cb1-9"><a href="#cb1-9"></a>	else</span>
<span id="cb1-10"><a href="#cb1-10"></a>		1) Assume every 0th, 2nd, 4th, etc. term is &quot;honest&quot; and that the rest are</span>
<span id="cb1-11"><a href="#cb1-11"></a>		&quot;fake&quot;; construct a tentative AP (call it BP) with the honest terms by</span>
<span id="cb1-12"><a href="#cb1-12"></a>		taking the difference between these honest terms to find the rate of change</span>
<span id="cb1-13"><a href="#cb1-13"></a>		*m*, and see if mutate(BP) = MP --- if so, then return BP.</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>		2) Otherwise, every 1st, 3rd, 5th, etc. term is &quot;honest&quot; --- so</span>
<span id="cb1-16"><a href="#cb1-16"></a>		reconstruct BP, and check if mutate(AP) = MP (i.e., check that the</span>
<span id="cb1-17"><a href="#cb1-17"></a>		dishonest terms from mutate(BP) are the same as those in the given MP).</span>
<span id="cb1-18"><a href="#cb1-18"></a>		If the check fails, then we know that the input was not a true MP ---</span>
<span id="cb1-19"><a href="#cb1-19"></a>		the original AP was not an arithmetic progression to begin with!</span>
<span id="cb1-20"><a href="#cb1-20"></a>	end</span>
<span id="cb1-21"><a href="#cb1-21"></a>end</span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a># Convert AP into MP</span>
<span id="cb1-24"><a href="#cb1-24"></a>def mutate(AP)</span>
<span id="cb1-25"><a href="#cb1-25"></a>	MP = []</span>
<span id="cb1-26"><a href="#cb1-26"></a>	for every term 'a' in AP:</span>
<span id="cb1-27"><a href="#cb1-27"></a>		MP.insert(make_odd(a))</span>
<span id="cb1-28"><a href="#cb1-28"></a>	end</span>
<span id="cb1-29"><a href="#cb1-29"></a>end</span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a># Divide an integer n by 2 until it becomes odd. The edge case is when n is 0,</span>
<span id="cb1-32"><a href="#cb1-32"></a># because dividing by 2 repeatedly does not change its parity.</span>
<span id="cb1-33"><a href="#cb1-33"></a>def make_odd(n)</span>
<span id="cb1-34"><a href="#cb1-34"></a>	if n is odd or n is 0</span>
<span id="cb1-35"><a href="#cb1-35"></a>		return n</span>
<span id="cb1-36"><a href="#cb1-36"></a>	else</span>
<span id="cb1-37"><a href="#cb1-37"></a>		return (make_odd(n/2))</span>
<span id="cb1-38"><a href="#cb1-38"></a>	end</span>
<span id="cb1-39"><a href="#cb1-39"></a>end</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>pseudocode.txt</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/srm485-afraid-of-even/pseudocode.txt"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/srm485-afraid-of-even/pseudocode.txt" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>The interesting point is in line 18; thanks to our math work, we can even declare that a given mutated sequence was somehow either tampered with, or that the original sequence was not an arithmetic progression!
We can make these assertions because we’ve exhausted all possible cases of arithmetic sequences and their mutations — and if things don’t fit the way we expect them to, then the only conclusion is that the given sequence <span class="math inline">\(MP\)</span> was not a byproduct of mutating an <em>arithmetic sequence</em>, but some other kind of sequence.
Behold the power of math!</p>
<p>The other thing is that in line 34 we allow <span class="math inline">\(0\)</span> as a possible value in <span class="math inline">\(AP\)</span>.
This means that after a mutation, we might still have an even number (<span class="math inline">\(0\)</span>) in <span class="math inline">\(MP\)</span>!
Although this sounds like it would break all of the mathematic discussion we’ve had so far, it does not — the proof is in the Haskell code below.
The short answer is that a <span class="math inline">\(0\)</span> is harmless because it shares the same quality — immutability — with all other originally odd terms in <span class="math inline">\(AP\)</span>; thus, treating it as an “odd” number does not change our logic.</p>
<h1 id="haskell-version">Haskell version</h1>
<div class="code-and-raw">
<div class="sourceCode" id="cb2" data-startFrom="1"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">module</span> <span class="dt">Unmutate</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">-- Convert mutated numbers back into an arithmetic progression (if possible).</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ot">unmutate ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]</span>
<span id="cb2-5"><a href="#cb2-5"></a>unmutate ts</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="co">-- The input must be at least 4 terms!</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="op">|</span> <span class="fu">length</span> ts <span class="op">&lt;</span> <span class="dv">4</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="op">|</span> <span class="fu">all</span> (<span class="op">==</span>t) ts <span class="ot">=</span> <span class="dt">Just</span> ts</span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="op">|</span> isArithmetic ts <span class="ot">=</span> <span class="dt">Just</span> ts</span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="op">|</span> mutate bp1 <span class="op">==</span> ts <span class="ot">=</span> <span class="dt">Just</span> bp1</span>
<span id="cb2-11"><a href="#cb2-11"></a>  <span class="op">|</span> mutate bp2 <span class="op">==</span> ts <span class="ot">=</span> <span class="dt">Just</span> bp2</span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="co">-- Could optionally raise an error saying ts was not derived from an</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>  <span class="co">-- arithmetic progression in the first place!</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>  <span class="kw">where</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>  t <span class="ot">=</span> <span class="fu">head</span> ts</span>
<span id="cb2-17"><a href="#cb2-17"></a>  <span class="co">-- O_F, O, O_F, O...</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>  bp1Terms <span class="ot">=</span> everyNth0 <span class="dv">2</span> ts</span>
<span id="cb2-19"><a href="#cb2-19"></a>  bp1 <span class="ot">=</span> makeBP (<span class="fu">length</span> ts) <span class="dt">False</span> bp1Terms</span>
<span id="cb2-20"><a href="#cb2-20"></a>  <span class="co">-- O, O_F, O, O_F...</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>  bp2Terms <span class="ot">=</span> everyNth <span class="dv">2</span> ts</span>
<span id="cb2-22"><a href="#cb2-22"></a>  bp2 <span class="ot">=</span> makeBP (<span class="fu">length</span> ts) <span class="dt">True</span> bp2Terms</span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="co">-- Create a tentative arithmetic progression &quot;BP&quot; from the given arguments. The</span></span>
<span id="cb2-25"><a href="#cb2-25"></a><span class="co">-- `makeFirstTerm` boolean determines whether we are dealing with a &quot;O_F, O,</span></span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="co">-- O_F, O...&quot; or a &quot;O, O_F, O, O_F&quot; pattern.</span></span>
<span id="cb2-27"><a href="#cb2-27"></a><span class="ot">makeBP ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb2-28"><a href="#cb2-28"></a>makeBP len makeFirstTerm originals</span>
<span id="cb2-29"><a href="#cb2-29"></a>  <span class="op">|</span> <span class="fu">length</span> originals <span class="op">&lt;</span> <span class="dv">2</span> <span class="ot">=</span> []</span>
<span id="cb2-30"><a href="#cb2-30"></a>  <span class="op">|</span> makeFirstTerm <span class="ot">=</span> (o0 <span class="op">-</span> m) <span class="op">:</span> <span class="fu">init</span> bp</span>
<span id="cb2-31"><a href="#cb2-31"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> bp</span>
<span id="cb2-32"><a href="#cb2-32"></a>  <span class="kw">where</span></span>
<span id="cb2-33"><a href="#cb2-33"></a>  o0 <span class="ot">=</span> originals<span class="op">!!</span><span class="dv">0</span></span>
<span id="cb2-34"><a href="#cb2-34"></a>  o1 <span class="ot">=</span> originals<span class="op">!!</span><span class="dv">1</span></span>
<span id="cb2-35"><a href="#cb2-35"></a>  m <span class="ot">=</span> <span class="fu">div</span> (o1 <span class="op">-</span> o0) <span class="dv">2</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>  bp <span class="ot">=</span> <span class="fu">reverse</span></span>
<span id="cb2-37"><a href="#cb2-37"></a>    <span class="op">.</span> <span class="fu">foldl</span> (\acc n <span class="ot">-&gt;</span> (m<span class="op">*</span>n <span class="op">+</span> o0)<span class="op">:</span>acc) []</span>
<span id="cb2-38"><a href="#cb2-38"></a>    <span class="op">$</span> <span class="fu">take</span> len [<span class="dv">0</span><span class="op">..</span>]</span>
<span id="cb2-39"><a href="#cb2-39"></a></span>
<span id="cb2-40"><a href="#cb2-40"></a><span class="ot">isArithmetic ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-41"><a href="#cb2-41"></a>isArithmetic ts</span>
<span id="cb2-42"><a href="#cb2-42"></a>  <span class="co">-- A progression (before we even get to whether it is arithmetic) must have</span></span>
<span id="cb2-43"><a href="#cb2-43"></a>  <span class="co">-- at least 2 terms in it.</span></span>
<span id="cb2-44"><a href="#cb2-44"></a>  <span class="op">|</span> <span class="fu">length</span> ts <span class="op">&lt;</span> <span class="dv">2</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb2-45"><a href="#cb2-45"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">all</span> (<span class="op">==</span>m) <span class="op">$</span> <span class="fu">zipWith</span> (<span class="op">-</span>) (<span class="fu">tail</span> ts) (<span class="fu">init</span> ts)</span>
<span id="cb2-46"><a href="#cb2-46"></a>  <span class="kw">where</span></span>
<span id="cb2-47"><a href="#cb2-47"></a>  t0 <span class="ot">=</span> ts<span class="op">!!</span><span class="dv">0</span></span>
<span id="cb2-48"><a href="#cb2-48"></a>  t1 <span class="ot">=</span> ts<span class="op">!!</span><span class="dv">1</span></span>
<span id="cb2-49"><a href="#cb2-49"></a>  m <span class="ot">=</span> t1 <span class="op">-</span> t0</span>
<span id="cb2-50"><a href="#cb2-50"></a></span>
<span id="cb2-51"><a href="#cb2-51"></a><span class="ot">mutate ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb2-52"><a href="#cb2-52"></a>mutate <span class="ot">=</span> <span class="fu">map</span> makeOdd</span>
<span id="cb2-53"><a href="#cb2-53"></a>  <span class="kw">where</span></span>
<span id="cb2-54"><a href="#cb2-54"></a><span class="ot">  makeOdd ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb2-55"><a href="#cb2-55"></a>  makeOdd n</span>
<span id="cb2-56"><a href="#cb2-56"></a>    <span class="co">-- 0 cannot be turned into an odd number! Keep it as is.</span></span>
<span id="cb2-57"><a href="#cb2-57"></a>    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb2-58"><a href="#cb2-58"></a>    <span class="op">|</span> <span class="fu">odd</span> n <span class="ot">=</span> n</span>
<span id="cb2-59"><a href="#cb2-59"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> makeOdd <span class="op">$</span> <span class="fu">div</span> n <span class="dv">2</span></span>
<span id="cb2-60"><a href="#cb2-60"></a></span>
<span id="cb2-61"><a href="#cb2-61"></a><span class="co">-- Given a list of 'a's, return the elements at indices [0n, 1n, 2n, 3n, ...].</span></span>
<span id="cb2-62"><a href="#cb2-62"></a><span class="co">-- E.g., given a list [0..] and n = 2, we get [0, 2, 4, 6..]. From</span></span>
<span id="cb2-63"><a href="#cb2-63"></a><span class="co">-- http://stackoverflow.com/a/2028758/437583.</span></span>
<span id="cb2-64"><a href="#cb2-64"></a><span class="ot">everyNth0 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb2-65"><a href="#cb2-65"></a>everyNth0 _ [] <span class="ot">=</span> []</span>
<span id="cb2-66"><a href="#cb2-66"></a>everyNth0 n as <span class="ot">=</span> <span class="fu">head</span> as <span class="op">:</span> everyNth0 n (<span class="fu">drop</span> n as)</span>
<span id="cb2-67"><a href="#cb2-67"></a></span>
<span id="cb2-68"><a href="#cb2-68"></a><span class="co">-- Same as `everyNth0`, but start at the nth element. E.g., given a list [0..]</span></span>
<span id="cb2-69"><a href="#cb2-69"></a><span class="co">-- and n = 2, we get [1, 3, 5, 7..].</span></span>
<span id="cb2-70"><a href="#cb2-70"></a><span class="ot">everyNth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb2-71"><a href="#cb2-71"></a>everyNth n <span class="ot">=</span> everyNth0 n <span class="op">.</span> <span class="fu">drop</span> (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>Unmutate.hs</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/srm485-afraid-of-even/Unmutate.hs"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/srm485-afraid-of-even/Unmutate.hs" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" id="cb3" data-startFrom="1"><pre class="sourceCode numberSource numberLines haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">import</span> <span class="dt">Test.Tasty</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">import</span> <span class="dt">Test.Tasty.HUnit</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span> <span class="kw">as</span> <span class="dt">QC</span></span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">import</span> <span class="dt">Unmutate</span></span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-11"><a href="#cb3-11"></a>main <span class="ot">=</span> defaultMain tests</span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="ot">tests ::</span> <span class="dt">TestTree</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>tests <span class="ot">=</span> testGroup <span class="st">&quot;Tests&quot;</span> [qcProps, unitTests]</span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="kw">data</span> <span class="dt">AP</span> <span class="ot">=</span> <span class="dt">AP</span> [<span class="dt">Integer</span>]</span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb3-18"><a href="#cb3-18"></a></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="co">-- Generate a random arithmetic progression.</span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">AP</span> <span class="kw">where</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>  arbitrary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>    <span class="co">-- Choose random m (change between terms).</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>    m <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Int</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>    <span class="co">-- Choose random first term. It's important that we make it into an</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>    <span class="co">-- Integer type, because if we use Int we might end up with integer</span></span>
<span id="cb3-26"><a href="#cb3-26"></a>    <span class="co">-- overflow if m is too large.</span></span>
<span id="cb3-27"><a href="#cb3-27"></a>    t <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Integer</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>    <span class="co">-- Choose random length of 4 to 50.</span></span>
<span id="cb3-29"><a href="#cb3-29"></a>    len <span class="ot">&lt;-</span> choose (<span class="dv">4</span>, <span class="dv">50</span>)</span>
<span id="cb3-30"><a href="#cb3-30"></a>    <span class="fu">return</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>      <span class="op">.</span> <span class="dt">AP</span></span>
<span id="cb3-32"><a href="#cb3-32"></a>      <span class="op">.</span> <span class="fu">foldl</span> (\acc n <span class="ot">-&gt;</span> ((<span class="fu">fromIntegral</span> m)<span class="op">*</span>n <span class="op">+</span> t)<span class="op">:</span>acc) []</span>
<span id="cb3-33"><a href="#cb3-33"></a>      <span class="op">$</span> <span class="fu">take</span> len [<span class="dv">0</span><span class="op">..</span>]</span>
<span id="cb3-34"><a href="#cb3-34"></a></span>
<span id="cb3-35"><a href="#cb3-35"></a><span class="ot">qcProps ::</span> <span class="dt">TestTree</span></span>
<span id="cb3-36"><a href="#cb3-36"></a>qcProps <span class="ot">=</span> testGroup <span class="st">&quot;(checked by QuickCheck)&quot;</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>  [ QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in calculable (isJust))&quot;</span></span>
<span id="cb3-38"><a href="#cb3-38"></a>    (\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> isJust <span class="op">.</span> unmutate <span class="op">$</span> mutate ts)</span>
<span id="cb3-39"><a href="#cb3-39"></a>  , QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in a nonempty list)&quot;</span></span>
<span id="cb3-40"><a href="#cb3-40"></a>    (\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> <span class="fu">not</span></span>
<span id="cb3-41"><a href="#cb3-41"></a>      <span class="op">.</span> <span class="fu">null</span></span>
<span id="cb3-42"><a href="#cb3-42"></a>      <span class="op">.</span> fromJust</span>
<span id="cb3-43"><a href="#cb3-43"></a>      <span class="op">.</span> unmutate</span>
<span id="cb3-44"><a href="#cb3-44"></a>      <span class="op">$</span> mutate ts)</span>
<span id="cb3-45"><a href="#cb3-45"></a>  , QC.testProperty <span class="st">&quot;Unmutate (U(M(AP)) results in an arithmetic progression)&quot;</span></span>
<span id="cb3-46"><a href="#cb3-46"></a>    (\(<span class="dt">AP</span> ts) <span class="ot">-&gt;</span> isArithmetic</span>
<span id="cb3-47"><a href="#cb3-47"></a>      <span class="op">.</span> fromJust</span>
<span id="cb3-48"><a href="#cb3-48"></a>      <span class="op">.</span> unmutate</span>
<span id="cb3-49"><a href="#cb3-49"></a>      <span class="op">$</span> mutate ts)</span>
<span id="cb3-50"><a href="#cb3-50"></a>  ]</span>
<span id="cb3-51"><a href="#cb3-51"></a></span>
<span id="cb3-52"><a href="#cb3-52"></a><span class="ot">unitTests ::</span> <span class="dt">TestTree</span></span>
<span id="cb3-53"><a href="#cb3-53"></a>unitTests <span class="ot">=</span> testGroup <span class="st">&quot;Unit tests&quot;</span></span>
<span id="cb3-54"><a href="#cb3-54"></a>  [ testCase <span class="st">&quot;Unmutate (empty list is not calculable)&quot;</span></span>
<span id="cb3-55"><a href="#cb3-55"></a>    <span class="op">$</span> unmutate ([]<span class="ot">::</span>[<span class="dt">Int</span>])</span>
<span id="cb3-56"><a href="#cb3-56"></a>    <span class="op">@?=</span> <span class="dt">Nothing</span></span>
<span id="cb3-57"><a href="#cb3-57"></a>  , testCase <span class="st">&quot;Unmutate (AP is all odd, so AP == MP)&quot;</span></span>
<span id="cb3-58"><a href="#cb3-58"></a>    <span class="op">$</span> unmutate [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-59"><a href="#cb3-59"></a>    <span class="op">@?=</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-60"><a href="#cb3-60"></a>  , testCase <span class="st">&quot;Unmutate (m = 0, so all elements in mp are the same)&quot;</span></span>
<span id="cb3-61"><a href="#cb3-61"></a>    <span class="op">$</span> unmutate [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-62"><a href="#cb3-62"></a>    <span class="op">@?=</span> <span class="dt">Just</span> [<span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-63"><a href="#cb3-63"></a>  , testCase <span class="st">&quot;Unmutate (known case 1)&quot;</span></span>
<span id="cb3-64"><a href="#cb3-64"></a>    <span class="op">$</span> unmutate [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-65"><a href="#cb3-65"></a>    <span class="op">@?=</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-66"><a href="#cb3-66"></a>  , testCase <span class="st">&quot;Unmutate (known case 2)&quot;</span></span>
<span id="cb3-67"><a href="#cb3-67"></a>    <span class="op">$</span> unmutate [<span class="dv">7</span>, <span class="dv">47</span>, <span class="dv">5</span>, <span class="dv">113</span>, <span class="dv">73</span>, <span class="dv">179</span>, <span class="dv">53</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-68"><a href="#cb3-68"></a>    <span class="op">@?=</span> <span class="dt">Just</span> [<span class="dv">14</span>, <span class="dv">47</span>, <span class="dv">80</span>, <span class="dv">113</span>, <span class="dv">146</span>, <span class="dv">179</span>, <span class="dv">212</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-69"><a href="#cb3-69"></a>  , testCase <span class="st">&quot;Unmutate (known case 3)&quot;</span></span>
<span id="cb3-70"><a href="#cb3-70"></a>    <span class="op">$</span> unmutate [<span class="dv">749</span>, <span class="dv">999</span>, <span class="dv">125</span>, <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-71"><a href="#cb3-71"></a>    <span class="op">@?=</span> <span class="dt">Just</span> [<span class="dv">1498</span>, <span class="dv">999</span>, <span class="dv">500</span>, <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-72"><a href="#cb3-72"></a>  , testCase <span class="st">&quot;Unmutate (known case 4)&quot;</span></span>
<span id="cb3-73"><a href="#cb3-73"></a>    <span class="op">$</span> unmutate [<span class="op">-</span><span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">33</span>, <span class="dv">11</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-74"><a href="#cb3-74"></a>    <span class="op">@?=</span> <span class="dt">Just</span> [<span class="op">-</span><span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">22</span>, <span class="dv">33</span>, <span class="dv">44</span><span class="ot"> ::</span> <span class="dt">Int</span>]</span>
<span id="cb3-75"><a href="#cb3-75"></a>  ]</span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>test-unmutate.hs</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/srm485-afraid-of-even/test-unmutate.hs"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/srm485-afraid-of-even/test-unmutate.hs" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>As you can see, most of the real work involves identifying the <strong>original, immutable numbers</strong> we can work with as-is (<span class="math inline">\(\mathrm{O}\)</span>) (as opposed to the ones we have to ignore (<span class="math inline">\(\mathrm{O_F}\)</span>)) to construct our tentative sister arithmetic progression <span class="math inline">\(BP\)</span>.</p>
<h1 id="ruby-version">Ruby version</h1>
<div class="code-and-raw">
<div class="sourceCode" id="cb4" data-startFrom="1"><pre class="sourceCode numberSource numberLines ruby"><code class="sourceCode ruby"><span id="cb4-1"><a href="#cb4-1"></a><span class="cf">module</span> <span class="dt">Unmutate</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="cf">def</span> <span class="dt">Unmutate</span><span class="at">.unmutate</span>(ts)</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="cf">if</span> ts<span class="at">.size</span> <span class="kw">&lt;</span> <span class="dv">4</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>      <span class="cf">return</span> <span class="dv">nil</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="cf">end</span></span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a>    bp1_terms <span class="kw">=</span> every_nth0(<span class="dv">2</span>, ts)</span>
<span id="cb4-8"><a href="#cb4-8"></a>    bp1 <span class="kw">=</span> make_BP(ts<span class="at">.size</span>, <span class="dv">false</span>, bp1_terms)</span>
<span id="cb4-9"><a href="#cb4-9"></a>    bp2_terms <span class="kw">=</span> every_nth(<span class="dv">2</span>, ts)</span>
<span id="cb4-10"><a href="#cb4-10"></a>    bp2 <span class="kw">=</span> make_BP(ts<span class="at">.size</span>, <span class="dv">true</span>, bp2_terms)</span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="cf">if</span> ts<span class="at">.uniq.size</span> <span class="kw">==</span> <span class="dv">1</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>      ts</span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="cf">elsif</span> <span class="dt">Unmutate</span><span class="at">.arithmetic?</span>(ts)</span>
<span id="cb4-15"><a href="#cb4-15"></a>      ts</span>
<span id="cb4-16"><a href="#cb4-16"></a>    <span class="cf">elsif</span> <span class="dt">Unmutate</span><span class="at">.mutate</span>(bp1) <span class="kw">==</span> ts</span>
<span id="cb4-17"><a href="#cb4-17"></a>      bp1</span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="cf">elsif</span> <span class="dt">Unmutate</span><span class="at">.mutate</span>(bp2) <span class="kw">==</span> ts</span>
<span id="cb4-19"><a href="#cb4-19"></a>      bp2</span>
<span id="cb4-20"><a href="#cb4-20"></a>    <span class="cf">else</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>      <span class="dv">nil</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>    <span class="cf">end</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>  <span class="cf">end</span></span>
<span id="cb4-24"><a href="#cb4-24"></a></span>
<span id="cb4-25"><a href="#cb4-25"></a>  <span class="cf">def</span> <span class="dt">Unmutate</span><span class="at">.make_BP</span>(len, make_first_term, originals)</span>
<span id="cb4-26"><a href="#cb4-26"></a>    <span class="cf">if</span> originals<span class="at">.size</span> <span class="kw">&lt;</span> <span class="dv">2</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>      <span class="cf">return</span> <span class="kw">[]</span></span>
<span id="cb4-28"><a href="#cb4-28"></a>    <span class="cf">end</span></span>
<span id="cb4-29"><a href="#cb4-29"></a></span>
<span id="cb4-30"><a href="#cb4-30"></a>    o0 <span class="kw">=</span> originals<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb4-31"><a href="#cb4-31"></a>    o1 <span class="kw">=</span> originals<span class="kw">[</span><span class="dv">1</span><span class="kw">]</span></span>
<span id="cb4-32"><a href="#cb4-32"></a>    m <span class="kw">=</span> (o1 <span class="kw">-</span> o0) <span class="kw">/</span> <span class="dv">2</span></span>
<span id="cb4-33"><a href="#cb4-33"></a>    bp <span class="kw">=</span> <span class="kw">[]</span></span>
<span id="cb4-34"><a href="#cb4-34"></a></span>
<span id="cb4-35"><a href="#cb4-35"></a>    <span class="cf">for</span> n <span class="cf">in</span> (<span class="dv">0</span><span class="kw">..</span>(len <span class="kw">-</span> <span class="dv">1</span>)) <span class="cf">do</span></span>
<span id="cb4-36"><a href="#cb4-36"></a>      bp <span class="kw">&lt;&lt;</span> m<span class="kw">*</span>n <span class="kw">+</span> o0</span>
<span id="cb4-37"><a href="#cb4-37"></a>    <span class="cf">end</span></span>
<span id="cb4-38"><a href="#cb4-38"></a></span>
<span id="cb4-39"><a href="#cb4-39"></a>    <span class="cf">if</span> make_first_term</span>
<span id="cb4-40"><a href="#cb4-40"></a>      <span class="kw">[</span>o0 <span class="kw">-</span> m<span class="kw">]</span> <span class="kw">+</span> bp<span class="at">.take</span>(len <span class="kw">-</span> <span class="dv">1</span>)</span>
<span id="cb4-41"><a href="#cb4-41"></a>    <span class="cf">else</span></span>
<span id="cb4-42"><a href="#cb4-42"></a>      bp</span>
<span id="cb4-43"><a href="#cb4-43"></a>    <span class="cf">end</span></span>
<span id="cb4-44"><a href="#cb4-44"></a>  <span class="cf">end</span></span>
<span id="cb4-45"><a href="#cb4-45"></a></span>
<span id="cb4-46"><a href="#cb4-46"></a>  <span class="cf">def</span> <span class="dt">Unmutate</span><span class="at">.mutate</span>(ts)</span>
<span id="cb4-47"><a href="#cb4-47"></a>    ts<span class="at">.map</span><span class="kw">{|</span>t<span class="kw">|</span> make_odd t<span class="kw">}</span></span>
<span id="cb4-48"><a href="#cb4-48"></a>  <span class="cf">end</span></span>
<span id="cb4-49"><a href="#cb4-49"></a></span>
<span id="cb4-50"><a href="#cb4-50"></a>  <span class="cf">def</span> <span class="dt">Unmutate</span><span class="at">.arithmetic?</span>(ts)</span>
<span id="cb4-51"><a href="#cb4-51"></a>    <span class="cf">if</span> ts<span class="at">.size</span> <span class="kw">&lt;</span> <span class="dv">2</span></span>
<span id="cb4-52"><a href="#cb4-52"></a>      <span class="cf">return</span> <span class="dv">false</span></span>
<span id="cb4-53"><a href="#cb4-53"></a>    <span class="cf">end</span></span>
<span id="cb4-54"><a href="#cb4-54"></a></span>
<span id="cb4-55"><a href="#cb4-55"></a>    m <span class="kw">=</span> ts<span class="kw">[</span><span class="dv">1</span><span class="kw">]</span> <span class="kw">-</span> ts<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb4-56"><a href="#cb4-56"></a>    ms <span class="kw">=</span> ts<span class="at">.drop</span>(<span class="dv">1</span>)<span class="at">.zip</span>(ts<span class="at">.take</span>(ts<span class="at">.size</span> <span class="kw">-</span> <span class="dv">1</span>))</span>
<span id="cb4-57"><a href="#cb4-57"></a></span>
<span id="cb4-58"><a href="#cb4-58"></a>    ms<span class="at">.each</span> <span class="cf">do</span> <span class="kw">|</span>t1, t0<span class="kw">|</span></span>
<span id="cb4-59"><a href="#cb4-59"></a>      <span class="cf">if</span> (t1 <span class="kw">-</span> t0) !<span class="kw">=</span> m</span>
<span id="cb4-60"><a href="#cb4-60"></a>        <span class="cf">return</span> <span class="dv">false</span></span>
<span id="cb4-61"><a href="#cb4-61"></a>      <span class="cf">end</span></span>
<span id="cb4-62"><a href="#cb4-62"></a>    <span class="cf">end</span></span>
<span id="cb4-63"><a href="#cb4-63"></a></span>
<span id="cb4-64"><a href="#cb4-64"></a>    <span class="dv">true</span></span>
<span id="cb4-65"><a href="#cb4-65"></a>  <span class="cf">end</span></span>
<span id="cb4-66"><a href="#cb4-66"></a><span class="cf">end</span></span>
<span id="cb4-67"><a href="#cb4-67"></a></span>
<span id="cb4-68"><a href="#cb4-68"></a><span class="cf">def</span> make_odd(t)</span>
<span id="cb4-69"><a href="#cb4-69"></a>  <span class="cf">if</span> t<span class="at">.odd?</span> <span class="kw">||</span> t <span class="kw">==</span> <span class="dv">0</span></span>
<span id="cb4-70"><a href="#cb4-70"></a>    t</span>
<span id="cb4-71"><a href="#cb4-71"></a>  <span class="cf">else</span></span>
<span id="cb4-72"><a href="#cb4-72"></a>    make_odd(t<span class="kw">/</span><span class="dv">2</span>)</span>
<span id="cb4-73"><a href="#cb4-73"></a>  <span class="cf">end</span></span>
<span id="cb4-74"><a href="#cb4-74"></a><span class="cf">end</span></span>
<span id="cb4-75"><a href="#cb4-75"></a></span>
<span id="cb4-76"><a href="#cb4-76"></a><span class="cf">def</span> every_nth0(n, ts)</span>
<span id="cb4-77"><a href="#cb4-77"></a>  arr <span class="kw">=</span> <span class="kw">[]</span></span>
<span id="cb4-78"><a href="#cb4-78"></a>  <span class="cf">for</span> i <span class="cf">in</span> (<span class="dv">0</span><span class="kw">..</span>(ts<span class="at">.size</span> <span class="kw">-</span> <span class="dv">1</span>)) <span class="cf">do</span></span>
<span id="cb4-79"><a href="#cb4-79"></a>    <span class="cf">if</span> i <span class="kw">%</span> n <span class="kw">==</span> <span class="dv">0</span></span>
<span id="cb4-80"><a href="#cb4-80"></a>      arr <span class="kw">&lt;&lt;</span> ts<span class="kw">[</span>i<span class="kw">]</span></span>
<span id="cb4-81"><a href="#cb4-81"></a>    <span class="cf">end</span></span>
<span id="cb4-82"><a href="#cb4-82"></a>  <span class="cf">end</span></span>
<span id="cb4-83"><a href="#cb4-83"></a>  arr</span>
<span id="cb4-84"><a href="#cb4-84"></a><span class="cf">end</span></span>
<span id="cb4-85"><a href="#cb4-85"></a></span>
<span id="cb4-86"><a href="#cb4-86"></a><span class="cf">def</span> every_nth(n, ts)</span>
<span id="cb4-87"><a href="#cb4-87"></a>  arr <span class="kw">=</span> <span class="kw">[]</span></span>
<span id="cb4-88"><a href="#cb4-88"></a>  <span class="cf">for</span> i <span class="cf">in</span> (<span class="dv">0</span><span class="kw">..</span>(ts<span class="at">.size</span> <span class="kw">-</span> <span class="dv">1</span>)) <span class="cf">do</span></span>
<span id="cb4-89"><a href="#cb4-89"></a>    <span class="cf">if</span> (i <span class="kw">+</span> <span class="dv">1</span>) <span class="kw">%</span> n <span class="kw">==</span> <span class="dv">0</span></span>
<span id="cb4-90"><a href="#cb4-90"></a>      arr <span class="kw">&lt;&lt;</span> ts<span class="kw">[</span>i<span class="kw">]</span></span>
<span id="cb4-91"><a href="#cb4-91"></a>    <span class="cf">end</span></span>
<span id="cb4-92"><a href="#cb4-92"></a>  <span class="cf">end</span></span>
<span id="cb4-93"><a href="#cb4-93"></a>  arr</span>
<span id="cb4-94"><a href="#cb4-94"></a><span class="cf">end</span></span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>unmutate.rb</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/srm485-afraid-of-even/unmutate.rb"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/srm485-afraid-of-even/unmutate.rb" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<div class="code-and-raw">
<div class="sourceCode" id="cb5" data-startFrom="1"><pre class="sourceCode numberSource numberLines ruby"><code class="sourceCode ruby"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># Usage: ruby test-unmutate.rb</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="fu">require</span> <span class="vs">'minitest/autorun'</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="fu">require_relative</span> <span class="vs">'./unmutate.rb'</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="cf">class</span> <span class="dt">TestUnmutate</span> <span class="kw">&lt;</span> <span class="dt">Minitest</span><span class="kw">::</span><span class="dt">Test</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="cf">def</span> test_empty_list_incalculable</span>
<span id="cb5-8"><a href="#cb5-8"></a>    assert_equal <span class="dv">nil</span>, <span class="dt">Unmutate</span><span class="at">.unmutate</span>(<span class="kw">[]</span>)</span>
<span id="cb5-9"><a href="#cb5-9"></a>  <span class="cf">end</span></span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a>  <span class="cf">def</span> test_all_odd_no_change</span>
<span id="cb5-12"><a href="#cb5-12"></a>    assert_equal <span class="kw">[</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span><span class="kw">]</span>,</span>
<span id="cb5-13"><a href="#cb5-13"></a>      <span class="dt">Unmutate</span><span class="at">.unmutate</span>(<span class="kw">[</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span><span class="kw">]</span>)</span>
<span id="cb5-14"><a href="#cb5-14"></a>  <span class="cf">end</span></span>
<span id="cb5-15"><a href="#cb5-15"></a></span>
<span id="cb5-16"><a href="#cb5-16"></a>  <span class="cf">def</span> test_m_is_0</span>
<span id="cb5-17"><a href="#cb5-17"></a>    assert_equal <span class="kw">[</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span><span class="kw">]</span>,</span>
<span id="cb5-18"><a href="#cb5-18"></a>      <span class="dt">Unmutate</span><span class="at">.unmutate</span>(<span class="kw">[</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span><span class="kw">]</span>)</span>
<span id="cb5-19"><a href="#cb5-19"></a>  <span class="cf">end</span></span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a>  <span class="cf">def</span> test_known_case_1</span>
<span id="cb5-22"><a href="#cb5-22"></a>    assert_equal <span class="kw">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="kw">]</span>,</span>
<span id="cb5-23"><a href="#cb5-23"></a>      <span class="dt">Unmutate</span><span class="at">.unmutate</span>(<span class="kw">[</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">5</span><span class="kw">]</span>)</span>
<span id="cb5-24"><a href="#cb5-24"></a>  <span class="cf">end</span></span>
<span id="cb5-25"><a href="#cb5-25"></a></span>
<span id="cb5-26"><a href="#cb5-26"></a>  <span class="cf">def</span> test_known_case_2</span>
<span id="cb5-27"><a href="#cb5-27"></a>    assert_equal <span class="kw">[</span><span class="dv">14</span>, <span class="dv">47</span>, <span class="dv">80</span>, <span class="dv">113</span>, <span class="dv">146</span>, <span class="dv">179</span>, <span class="dv">212</span><span class="kw">]</span>,</span>
<span id="cb5-28"><a href="#cb5-28"></a>      <span class="dt">Unmutate</span><span class="at">.unmutate</span>(<span class="kw">[</span><span class="dv">7</span>, <span class="dv">47</span>, <span class="dv">5</span>, <span class="dv">113</span>, <span class="dv">73</span>, <span class="dv">179</span>, <span class="dv">53</span><span class="kw">]</span>)</span>
<span id="cb5-29"><a href="#cb5-29"></a>  <span class="cf">end</span></span>
<span id="cb5-30"><a href="#cb5-30"></a></span>
<span id="cb5-31"><a href="#cb5-31"></a>  <span class="cf">def</span> test_known_case_3</span>
<span id="cb5-32"><a href="#cb5-32"></a>    assert_equal <span class="kw">[</span><span class="dv">1498</span>, <span class="dv">999</span>, <span class="dv">500</span>, <span class="dv">1</span><span class="kw">]</span>,</span>
<span id="cb5-33"><a href="#cb5-33"></a>      <span class="dt">Unmutate</span><span class="at">.unmutate</span>(<span class="kw">[</span><span class="dv">749</span>, <span class="dv">999</span>, <span class="dv">125</span>, <span class="dv">1</span><span class="kw">]</span>)</span>
<span id="cb5-34"><a href="#cb5-34"></a>  <span class="cf">end</span></span>
<span id="cb5-35"><a href="#cb5-35"></a></span>
<span id="cb5-36"><a href="#cb5-36"></a>  <span class="cf">def</span> test_known_case_4</span>
<span id="cb5-37"><a href="#cb5-37"></a>    assert_equal <span class="kw">[-</span><span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">22</span>, <span class="dv">33</span>, <span class="dv">44</span><span class="kw">]</span>,</span>
<span id="cb5-38"><a href="#cb5-38"></a>      <span class="dt">Unmutate</span><span class="at">.unmutate</span>(<span class="kw">[-</span><span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">33</span>, <span class="dv">11</span><span class="kw">]</span>)</span>
<span id="cb5-39"><a href="#cb5-39"></a>  <span class="cf">end</span></span>
<span id="cb5-40"><a href="#cb5-40"></a><span class="cf">end</span></span></code></pre></div>
<div class="raw-link sourceCode">
<p> <code>test-unmutate.rb</code> <a class="raw" href="https://github.com/listx/listx_blog/blob/master/code/toy/srm485-afraid-of-even/test-unmutate.rb"><code>[GitHub]</code></a> <a class="raw" href="../code/toy/srm485-afraid-of-even/test-unmutate.rb" mimetype="text/plain"><code>[Download]</code></a> </p>
</div>
</div>
<p>This Ruby version is essentially a port of the Haskell version.
The problem at hand is so mathematical that it makes sense to simply preserve the clean Haskell definitions.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I hope you enjoyed this somewhat prolonged mathematical adventure.
The most interesting part for me was seeing the problem as a linear equation, and using the formula (which I learned in high school) to derive powerful conclusions.
High school algebra is useful after all!
Until next time, happy hacking!</p>

		</div>

		<div id="footer">
			<img src="../favicon.png" id="brand-icon">
			<p>Copyright (C) 2013-2023 Linus Arver. All rights reserved.</p>
			<a href="https://github.com/listx/listx_blog">Site</a>
			<a href="https://github.com/listx/listx.github.io">generated</a>
			with
			<a href="https://jaspervdj.be/hakyll">Hakyll</a>
			and
			<a href="http://sebastiaanvisser.github.com/clay">Clay</a>.
			<br>
			<a href="../atom.xml">Atom feed</a>
		</div>
	</body>
</html>
